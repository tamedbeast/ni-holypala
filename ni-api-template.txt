# Debug

> All functions when used will be prepended with `ni.debug`.

---

## print

Arguments:

- **message** `string`

Returns: `void`

Prints the message if `ni.vars.debug` is set to true.

```lua
ni.debug.print("Test") -- Won't print
ni.vars.debug = true
ni.debug.print("Test") -- Will print
```

## log

Arguments:

- **message** `string`
- **error** `boolean` _optional_

Returns: `void`

Prints the message in the console of ni's application. Error is optional, true for error message and empty or false or normal.

```lua
ni.debug.log("Test")
```
# Generic

> This is for generic functions that don't fit in the categories.

---

## delayfor

Arguments:

- **delay** `number`
- **func** `function`

Returns: `bool`

Delays a call for specified time on a specific function.

```lua
ni.delayfor(2, function()
  ni.spell.cast("Shadow Bolt", "target")
end);
-- Shadow Bolt will be casted 2 seconds from now
```

## require

Arguments:

- **filename** `string`

Returns: `return from file loaded`

Ni's version of lua's require. It's used to load files into another chunk giving access to other functions without being loaded many times as it's cached each initial load (reload will clear out the cache). The string passed for the file can be the filename without the .lua extension, or it can include the .lua extension. It will search in the Data folder for this file. Additionally, you can use absolute paths (for example C:\Some Folder\file.lua).

```lua
local data = ni.utils.require("Example"); --This will load the data file called Example.lua from the data folder into the local variable data

print(example.version()); --In the example file there is already a function called "version", so here it would print the version
```
# Healing

> All functions when used will be prepended with `ni.healing`.

---

## debufftoblacklist

Arguments:

- **id** `number`: the ID of the debuff to add to the blacklist.

Use this function to add a debuff ID to the blacklisteddispels table.

```lua
local bad = { 47867, 47813, 47864 };
for i = 1, #bad
	local badDebuff = bad[i];
	if UnitLevel("player") >= 80 then
		ni.healing.debufftoblacklist(badDebuff)
	end
end
```

## dontdispel

Arguments:

- **t** `string`: the unit to check.

Returns:

- `boolean`: true if the unit's debuff is blacklisted or not dispellable, false otherwise.

Use this function to check if a unit's debuff is blacklisted or not dispellable.

```lua
	if ni.healing.dontdispel("player") then
		-- do stuff
	end
```

## candispel

Arguments:

- **t** `string`: the unit to check.

Returns:

- `boolean`: true if the unit's debuff is dispellable, false otherwise.

Use this function to check if a unit's debuff is dispellable.

```lua
	if ni.healing.candispel("player") then
		-- do stuff
	end
```

## debufftypedispellable

Arguments:

- **debufftype** `string`: the debuff type to check.

Returns:

- `boolean`: true if the debuff type is dispellable for the current class, false otherwise.

Use this function to check if a debuff type is dispellable for a specific class.

```lua
	if healing.debufftypedispellable("Poison") then
		-- Your class can dispel poison debuffs
	end
```

# Tanks

> All functions when used will be prepended with `ni.tanks()`.

---

Returns:

If the main tank and off-tank units have been manually assigned in the game UI, this function will return those units. If not, the function will attempt to find the two tanks based on the units currently in the player's party/raid. If there are not enough tanks in the group, the function will return the two tanks with the highest maximum health.

```lua
local mainTank, offTank = ni.tanks()
```


## Example

Apart from functions listed below, it's possible to call `mainTank` or `offTank` as a shorthand for calling any function in [Members](api/members.md) and passing `mainTank` or `offTank` as the first argument.

```lua
local mainTank, offTank = ni.tanks()
if mainTank then
	if mainTank:combat()
	and mainTank:debufftype("Poison")
	and mainTank:dispel() then
		-- do stuff
	end
end
if offTank then
	if offTank:combat()
	and not offTank:auras("48066||6788") then
		ni.spell.cast(48066, offTank.unit)
	end
end
```

```lua
-- Get the main tank and off-tank units
local mainTank, offTank = ni.tanks()

-- If we were able to determine the tanks, we can use them in combat
if mainTank then
	if UnitExists(mainTank.unit)
	and mainTank:valid(48378, false, true) then -- check valid one time for all healing spells
		if mainTank:hp() < 40
		and not ni.player.ismoving()
		and ni.spell.available(48378) then
			ni.spell.cast(48378, mainTank.unit)
		end			
		if mainTank:hp() < 90 
		and ni.spell.available(48441)
		and not mainTank:buff(48441, "player") then
			ni.spell.cast(48441, mainTank.unit)
		end	
	end
end
if offTank then
	if UnitExists(offTank.unit)
	and offTank:valid(48378, false, true) then -- check valid one time for all healing spells
		if offTank:hp() < 70
		and ni.spell.available(48451) 
		and (not offTank:buff(48451, player) 
		or ni.unit.buffstacks(offTank.unit, 48451, "player") < 3) then
			ni.spell.cast(48451, offTank.unit)
		end			
		if offTank:hp() < 90 
		and ni.spell.available(48441)
		and not offTank:buff(48441, "player") then
			ni.spell.cast(48441, offTank.unit)
		end	
	end
end
```
# Members

> All functions when used will be prepended with `ni.members`.

---
## Iterating with member table
If you don't need them to be sorted by range and hp:

```lua
for i = 1, #ni.members do
    ...
end
```
If you only need sorting by range:

```lua
for i = 1, #ni.members.inrange("player", 40) do
    ...
end
```

If you need to sort by range and hp:
```lua
for i = 1, #ni.members.sort() do
    ...
end
```

## istank

Returns: `boolean`

Returns true if the unit is a tank or has the capability to tank, and false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:istank() then
		-- The unit is tank, do stuff...
	end
end
```

## ishealer

Returns: `boolean`

Returns true if the unit is a healer or has the capability to healer, and false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:ishealer() then
		-- The unit is healer, do stuff... 
	end
end
```

## isdps

Returns: `boolean`

Returns true if the unit is a DPS or has the capability to DPS, and false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:isdps() then
		-- The unit is DPS, do stuff... 
	end
end
```

## iscaster

Returns: `boolean`

Returns true if the unit is a Caster DPS or has the capability to Caster DPS, and false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:iscaster() then
		-- The unit is Caster DPS, do stuff... 
	end
end
```

## ismelee

Returns: `boolean`

Returns true if the unit is a Melee DPS or has the capability to Melee DPS, and false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:ismelee() then
		-- The unit is Melee DPS, do stuff... 
	end
end
```

## location

Returns: `number`, `number`, `number`, `number`

Returns the current location of the unit in the game world as four separate values: x, y, z, and r (rotation).

```lua
for i = 1, #ni.members do
	local x, y, z, r = ni.members[i]:location()
	if x and y and z and r then
		-- The unit's location was successfully retrieved
	end
end
```

## combat

Returns: `boolean`

Returns true if the unit is currently in combat, and false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:combat() then
		-- The unit is in combat
	end
end
```

## aura

Arguments:

- **aura** `number` or `string`

Returns: `boolean`

Returns true if the unit has the specified aura, and false otherwise.

```lua
if ni.members[1]:aura(12345) then
    -- The unit has aura ID 12345
end

if ni.members[1]:aura("Arcane Intellect") then
    -- The unit has the "Arcane Intellect" aura
end
```

Note: You can use either the aura ID or the name of the aura as the argument for this function.

## auras
Arguments:

- **ids** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `boolean`

Checks if specified unit has certain buffs separated by `&&` or `||`.

```lua
if ni.members[1]:auras("63321&&Fel Armor") then
    -- Unit has both Life Tap and Fel Armor
end

if ni.members[1]:auras("63321||Fel Armor", "EXACT") then
    -- Unit has either Life Tap, or Fel Armor
end
```

Note: You can use either the buff IDs or names as the argument for this function.

## buffs

Arguments:

- **ids** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `boolean`

Checks if specified unit has certain buffs separated by `&&` or `||`.

```lua
if ni.members[1]:buffs("63321&&Fel Armor", "EXACT") then
    -- Unit has both Life Tap and Fel Armor
end

if ni.members[1]:buffs("63321||Fel Armor") then
   -- Target has either Life Tap, or Fel Armor
end
```

Note: You can use either the buff IDs or names as the argument for this function.

## debuffs

Arguments:

- **ids** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `boolean`

Checks if specified unit has certain debuffs separated by `&&` or `||`.

```lua
if ni.members[1]:debuffs("Faerie Fire&&Curse of Agony", "PLAYER") then
    -- The unit has both Faerie Fire and Curse of Agony
end

if ni.members[1]:debuffs("Faerie Fire||Curse of Agony") then
    -- The has either Faerie Fire or Curse of Agony
end
```

Note: You can use either the debuff IDs or names as the argument for this function.

## debufftype

Type:

- **function**

Arguments:

- **string** `debuff type`

Returns: `boolean`

Returns true or false if the member accessed has the debuff type passed.

```lua
for i = 1, #ni.members do
	if ni.members[i]:debufftype("Disease") then
		--This member has a debuff type that is Disease on them
	end
end
```
Note: This function checks for any debuffs of the specified type, regardless of their specific name or ID.

## bufftype

Type:

- **function**

Arguments:

- **string** `buff type`

Returns: `boolean`

Returns true or false if the member accessed has the debuff type passed.

```lua
for i = 1, #ni.members do
	if ni.members[i]:bufftype("Magic") then
		--This member has a buff type that is Magic on them
	end
end
```

Note: This function checks for any buffs of the specified type, regardless of their specific name or ID.

## buff

Type:

- **function**

Arguments:

- **buff** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `UnitBuff`

Returns the same results from UnitBuff if they have the buff present.

```lua
for i = 1, #ni.members do
	if ni.members[i]:buff("Power Word: Shield", "PLAYER") then
		--This member has Power Word: Shield on them cast by the player
	end
end
```

Note: If the `filter` argument is not specified, this function will return the first matching buff it finds, regardless of its type.

## debuff

Type:

- **function**

Arguments:

- **debuff** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `UnitDebuff`

Returns the same results from UnitDebuff if they have the debuff present.

```lua
for i = 1, #ni.members do
	if ni.members[i]:debuff("Weakend Soul") then
		--This member has Weakend Soul on them
	end
end
```

Note: If the `filter` argument is not specified, this function will return the first matching debuff it finds, regardless of its type.

## dispel

Type:

- **variable**

Returns: `boolean`

This is the variable that returns true or false of the member accessed if you can dispel them and they have a debuff that requires dispelling.

```lua
for i = 1, #ni.members do
	if ni.members[i]:dispel() then
		--This member has a debuff that can be dispelled by you
	end
end
```

## hpraw

Type:

- **variable**

Returns: `number`

This is the variable that returns the absolute health of the member accessed.

```lua
for i = 1, #ni.members do
	if ni.members[i]:hpraw() < 30000 then
		-- This member has less then 30000 health
	end
end
```

## hpmax

Type:

- **variable**

Returns: `number`

Returns the maximum health of the unit.

```lua
for i = 1, #ni.members do
	local maxHealth = ni.members[i]:hpmax()
		...
end
```

## hp

Type:

- **variable**

Returns: `number`

This is the variable that returns the health percentage of the member accessed.

```lua
for i = 1, #ni.members do
	if ni.members[i]:hp() < 20 then
		--This member is below 20% health
	end
end
```

## range

Arguments: None

Returns: `boolean`

Returns true if the unit is within 40 yards of the player, false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:range() then
		-- Unit is within 40 yards of the player
	end
end	
```

## los

Arguments: None

Returns: `boolean`

Returns true if the player has line of sight to the unit, false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:los() then
		-- Player has line of sight to the unit
	end
end	
```

## facing

Arguments: None

Returns: `boolean`

Returns true if the player is facing the unit, false otherwise.

```lua
for i = 1, #ni.members do
	if ni.members[i]:facing() then
		-- Player is facing the unit
	end
end	
```

## valid

Arguments:

- **spell** `id|string`
- **facing** `boolean` _default: false_
- **los** `boolean` _default: false_

Returns: `boolean`

This functions ensures that a spell can be casted at specific unit. It includes checks such as:

```lua
for i = 1, #ni.members do
	if ni.members[i]:valid(48441, false, true) then
		-- All of the critera to be valid
	end
end	

for i = 1, #ni.members do
	if ni.members[i]:valid("Power Word: Shield", false, true) then
		-- All of the critera to be valid
	end
end	
```

## threat

Type:

- **variable**

Returns: `number`

This is the variable that returns the threat (number between -1 and 3) of the member accessed.

```lua
for i = 1, #ni.members do
	if ni.members[i]:threat() == -1 then
		--This member is not on any mobs threat list (99% chance just out of combat)
	end
end
```

## role

Returns the assigned role of the unit in the group.

Returns:

- A string representing the assigned role of the unit in the group.
- Returns an empty string if the unit has no assigned role.

Example:

```lua
for i = 1, #ni.members do
	if ni.members[i].role == "TANK" then
		-- Do something specific for tanks
	elseif ni.members[i].role == "HEALER"
		-- Do something specific for healer
	elseif ni.members[i].role == "CASTER"
		-- Do something specific for caster
	elseif ni.members[i].role == "MELEE"
		-- Do something specific for melee		
	end
end
```

## below

Arguments:

- **percent** `number`

Returns: `number`

Returns the number of members below the percentage passed as the argument.

```lua
local count = ni.members.below(90); --Count would then be the number of members below 90
```

## average

Arguments:

Returns: `number`

Returns the average health of all the members in your group.

```lua
if ni.members.average() < 20 then
	--Cast some raid wide health
end
```

## averageof

Arguments:

- **count** `number`

Returns: `number`

Returns the average health of the lowest members, averaged by the argument passed.

```lua
if ni.members.averageof(4) < 20 then
	--4 of the group members average the hp below 20%
end
```

## subgroupbelow

Arguments:

- `percent` (`number`): The percentage of health below which members are considered to have low health.
- `radius` (`number`): The maximum radius (in yards) within which to search for low health members.
- `owngroup` (`boolean`, optional): If `true`, search only within the player's subgroup. Otherwise, search within all subgroups.

Returns: 
- `near` (`number`): The number of members in the subgroup with low health.
- `lowestMember` (`table`): A table containing information about the subgroup member with the lowest health and closest to the player. The table contains the following keys:
    - `unit` (`string`): The name of the unit.
    - `hp` (`number`): The health percentage of the unit.
    - `near` (`number`): The number of other members within the specified radius that also have low health.

```lua
-- Search for the subgroup member with the lowest health below 20% within 10 yards.
local total, lowestMember = ni.members.subgroupbelow(20, 10)

if lowest and total >= 3
and lowest:valid(48072, false, true) then
	spellCast(48072, lowest.unit)
	return true;	
end
```

Note: This function searches for the lowest health member(s) in a player's subgroup and returns the number of members with low health and the one with the lowest health within a certain radius.

## inrange

Arguments:

- **unit** `guid|token`
- **distance** `number`

Returns: `table`

Returns a table of the members that are within the distance specified of the unit specified.

```lua
local members_around_me = ni.members.inrange("player", 10); --Returns a table of all the members within 10 yards of the player
```

## inrangebelow

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **hp** `number`

Returns: `table`

Returns a table of the members that are within the distance specified of the unit and are below the HP threshold passed.

```lua
local members_below = ni.members.inrangebelow("player", 10, 60); --Returns a table of all the members within 10 yards of the player that are below 60% health
```

---

> In addition to the main ni.members functions, ni.members itself is also a table of all the party/raid members of the unit. This is meant for iterating with the purpose of healing profiles or profiles that need access to the members. Below are the accessors, functions, and examples of this table:

## inrangewithbuff

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **buff** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of the members that are within the distance specified of the unit and also have the buff that is specified.

```lua
local members_with_riptide = ni.members.inrangewithbuff("player", 10, "Riptide", "PLAYER"); --Returns a table of all the members within 10 yards of the player that have the buff Riptide which was cast by the player
```

## inrangewithoutbuff

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **buff** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of the members that are within the distance specified of the unit and also do not have the buff that is specified.

```lua
local members_without_riptide = ni.members.inrangewithoutbuff("player", 10, "Riptide"); --Returns a table of all the members within 10 yards of the player that do not have the buff Riptide
```

## inrangewithdebufftype

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **str** `string`

Returns: `table`

Returns a table of the members that are within the distance specified of the unit and also have the debuff type that is specified.

```lua
local members_with_poison = ni.members.inrangewithdebufftype("player", 10, "Poison"); --Returns a table of all the members within 10 yards of the player that have a poison debuff
```

## inrangewithbufftype

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **str** `string`

Returns: `table`

Returns a table of the members that are within the distance specified of the unit and also have the buff type that is specified.

```lua
local members_with_magic_buff = ni.members.inrangewithbufftype("player", 10, "Magic"); --Returns a table of all the members within 10 yards of the player that have a magic buff
```

## inrangewithbuffbelow

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **buff** `name|id`
- **hp** `number`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of the members that are within the distance specified of the unit, have a health percentage below or equal to `hp`, and also have the buff that is specified.

```lua
local members_with_buff_below_50 = ni.members.inrangewithbuffbelow("player", 10, "Riptide", 50, "PLAYER"); 
-- Returns a table of all the members within 10 yards of the player with a health percentage below 
-- or equal to 50 that have the buff Riptide which was cast by the player
```

## inrangewithoutbuffbelow

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **buff** `name|id`
- **hp** `number`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of the members that are within the distance specified of the unit, have a health percentage below or equal to `hp`, and also do not have the buff that is specified.

```lua
local members_without_buff_below_50 = ni.members.inrangewithoutbuffbelow("player", 10, "Riptide", 50); 
--	Returns a table of all the members within 10 yards of the player with a health percentage below 
-- or equal to 50 that do not have the buff Riptide
```

## inrangewithdebuff

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **debuff** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of the members that are within the distance specified of the unit and also have the debuff that is specified.

```lua
local members_with_scorch = ni.members.inrangewithdebuff("target", 10, "Scorch", "PLAYER"); 
--	Returns a table of all the members within 10 yards of the target that 
-- have the debuff Scorch which was cast by the player
```

## inrangewithdebuffbelow

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **debuff** `name|id`
- **hp** `number`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of the members that are within the distance specified of the unit, below the hp percentage specified, and also have the debuff that is specified.

```lua
local members_with_scorch_below_50 = ni.members.inrangewithdebuffbelow("target", 10, "Scorch", 50, "PLAYER"); 
--	Returns a table of all the members within 10 yards of the target that have the debuff 
-- Scorch which was cast by the player and have less than 50% health
```

## inrangewithoutdebuff

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **debuff** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of members that are within the distance specified of the unit and do not have the debuff that is specified.

```lua
local members_without_curse = ni.members.inrangewithoutdebuff("player", 10, "Curse of Tongues", "PLAYER"); 
-- Returns a table of all the members within 10 yards of the player that 
-- do not have the Curse of Tongues debuff cast by the player
```

## inrangewithoutdebuffbelow

Arguments:

- **unit** `guid|token`
- **distance** `number`
- **debuff** `name|id`
- **hp** `number`
- **filter** `EXACT|PLAYER` _optional_

Returns: `table`

Returns a table of members that are within the distance specified of the unit, have less than or equal to the specified HP percentage, and do not have the debuff that is specified.

```lua
local members_without_curse_below_50_percent_hp = ni.members.inrangewithoutdebuffbelow("player", 10, "Curse of Tongues", 50, "PLAYER"); 
-- Returns a table of all the members within 10 yards of the player that have less than or equal to 50% HP, 
-- and do not have the Curse of Tongues debuff cast by the player
```

## addcustom

Arguments:

- **unit** `string`: the name of the unit to add as a custom member.
- **guid** `string` _optional_: the GUID of the unit to add as a custom member. If not provided, it will be obtained using `UnitGUID(unit)`.

This function adds a custom member to the members table. It creates a new GroupMember object with the provided unit and guid and adds it to the members table. If the custom member was successfully added, the members table is updated using the `updatemembers` function.

## removecustom

Arguments:
- **unit** `string`: the name of the unit to remove from the members table.

This function removes a custom member from the members table. It loops through the members table and removes the first element that matches the provided unit. It also removes the unit from the `cache` table in the `memberssetup` object. If a custom member was successfully removed, the members table is updated using the `updatemembers` function.
# Memory

> This is for the memory reading functions. Each function is prepended with `ni.memory`.

---

## baseaddress

Arguments:

Returns: `number, string`

Returns the base address of the client. Return 1 is the numeric value, return 2 is the string formatted value.

```lua
local base = ni.memory.baseaddress();
if ni.memory.read("byte", base + 0x12345678) == 0xCC then
	--Value at base + 0x12345678 is 0xCC
end
```

## objectpointer

Arguments:

- **object** `token|guid`

Returns: `number, string`

Returns the objects pointer. Return 1 is the numeric value, return 2 is the string formatted value.

```lua
local ptr = ni.memory.objectpointer("player");
```

## read

Arguments:

- **readtype** `string (see below)`
- **address** `number`
- **...** `offsets to add to the address to read off of` _optional_

Returns: `readtype value`

Returns the memory value in the type specified from the first argument.

```lua
local ptr = ni.memory.objectpointer("player");
local height = ni.memory.read("float", ptr, 0x8F8); --Gets the players height (MoP offset)
```

---

> The following strings are the accepted read type arguments for the read function.

## read types

```lua
"bool" --true/false formatted
"byte" --number formatted
"string" --string formatted
"float" --number formatted
"double" --number formatted
"int16"/"short" --number formatted
"int32"/"int" --number formatted
"int64" --string formatted formatted
"uint16"/"ushort" --number formatted
"uint"/"uint32" --number formatted
"uint64"/"GUID" --string formatted
```
# Object Manager

> All functions when used will be prepended with `ni.objectmanager`.

---

## contains

Arguments:

- **object** `token|guid|name`

Returns: `boolean`

Returns true or false if the value passed is within the object manager table (The object is around you).

```lua
if ni.objectmanager.contains("The Lich King") then
	--The Lich King is within our memory scope distance
end
```

## objectGUID

Arguments:

- **object** `token|guid|name`

Returns: `string`

Returns the objects GUID of the value passed, as long as they're within the object manager table.

```lua
local lich_king = ni.objectmanager.objectGUID("The Lich King");
if lich_king ~= nil then
	--The Lich King is within our memory scope distance, and we now have his GUID to work with on other functions.
end
```

---

> The object manager also features a set of functions and special way to provide an object oriented type programming for the lua. All of the way to access this feature is via `ni.objects`. Functions, variables and examples are as follows:

## guid

Type:

- **variable**

Returns: `string`

This is the variable that returns the GUID of the object accessed.

```lua
local tar = ni.objects["target"];
if tar:exists() then
	print(tar.guid) --Would print the GUID of the target
end
```

## name

Type:

- **variable**

Returns: `string`

This is the variable that returns the name of the object accessed.

```lua
local tar = ni.objects["target"];
if tar:exists() then
	print(tar.name) --Would print the name of the target
end
```

## type

Type:

- **variable**

Returns: `number`

This is the variable that returns the object type of the object accessed.

```lua
local tar = ni.objects["target"];
if tar:exists() then
	if tar.type == 3 then
		--The object is a unit
	elseif tar.type == 4 then
		--The object is a player
	elseif tar.type == 5 then
		--The object is a game object
	elseif tar.type == 6 then
		--The object is a dynamic object
	end
end
```

## exists

Type:

- **function**

Arguments:

Returns: `boolean`

Returns true or false if the object is within your memory scope.

```lua
local tar = ni.objects["focus"];
if tar:exists() then
	--focus object exists
end
```

## info

Type:

- **function**

Arguments:

Returns: `multi-ret`

Returns detailed information about the object.

```lua
local tar = ni.objects["focus"];
if tar:exists() then
	local x, y, z, facing, type, target, height = tar:info()
	if target ~= 0 then
		--We have the target GUID of the object.
	end
end
```

## hp

Type:

- **function**

Arguments:

Returns: `number`

Returns the objects health percentage.

```lua
local tar = ni.objects["The Lich King"];
if tar:exists() and tar:hp() < 20 then
	--Object has less than 20% health
end
```

## power

Type:

- **function**

Arguments:

- **type** `string` _optional_

Returns: `number`

Returns the current percent of the objects power (e.g. mana, energy, focus, etc.).

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:power("mana") >= 80 then
	--Target has, or has more than, 80% mana
end
```

## powermax

Type:

- **function**

Arguments:

- **type** `string` _optional_

Returns: `number`

Returns the maximum of the objects power (e.g. mana, energy, focus, etc.).

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:powermax("mana") >= 20000 then
	--Target has, or has more than, 20k mana
end
```

## unit

Type:

- **function**

Arguments:

Returns: `boolean`

Returns true or false if the object is a unit.

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:unit() then
	--Object is a unit.
end
```

## player

Type:

- **function**

Arguments:

Returns: `boolean`

Returns true or false if the object is a player.

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:player() then
	--Object is a player.
end
```

## canattack

Type:

- **function**

Arguments:

- **string** `token|guid` _optional_

Returns: `boolean`

Returns true or false if the object can attack the token specified, or player if empty.

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:canattack() then
	--Object can attack the player.
end
```

## canassist

Type:

- **function**

Arguments:

- **string** `token|guid` _optional_

Returns: `boolean`

Returns true or false if the object can assist the token specified, or player if empty.

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:canassist() then
	--Object can assist the player (They're friendly).
end
```

## los

Type:

- **function**

Arguments:

- **string** `token|guid` _optional_

Returns: `boolean`

Returns true or false if the object is in line of sight to the token specified, or player if empty.

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:los() then
	--Object is in line of sight to the player.
end
```

## cast

Type:

- **function**

Arguments:

- **string or number** `name|id`

Returns: `void`

Function to cast a spell onto the object.

```lua
local tar = ni.objects["The Lich King"];
if tar:exists() and tar:los() then
	tar:cast("Frost Bolt");
end
```

## castat

Type:

- **function**

Arguments:

- **string or number** `name|id`

Returns: `void`

Function to cast a spell at the location of the object if they're in line of sight.

```lua
local tar = ni.objects["The Lich King"];
if tar:exists() then
	tar:cast("Blizzard");
end
```

## combat

Type:

- **function**

Arguments:

Returns: `boolean`

Returns true or false if the object is in combat.

```lua
local tar = ni.objects["The Lich King"];
if tar:exists() and tar:combat() then
	--Object is in combat.
end
```

## isbehind

Type:

- **function**

Arguments:

- **target** `token|guid` _optional_
- **reverse** `boolean` _optional_

Returns: `boolean`

Returns true or false if the object is behind the token specified, or player if empty. If reverse is specified as true, it's the opposite direction (i.e. the player is behind the object).

```lua
local tar = ni.objects["target"];
if tar:exists() then
	if tar:isbehind("player", true) then
		--The player is behind the object.
	end
	if tar:isbehind() then
		--The object is behind the player
	end
end
```

## isfacing

Type:

- **function**

Arguments:

- **target** `token|guid` _optional_
- **reverse** `boolean` _optional_

Returns: `boolean`

Returns true or false if the object is facing the token specified, or player if empty. If reverse is specified as true, it's the opposite direction (i.e. the player is facing the object).

```lua
local tar = ni.objects["target"];
if tar:exists() then
	if tar:isfacing("player", true) then
		--The player is facing the object.
	end
	if tar:isfacing() then
		--The object is facing the player
	end
end
```

## distance

Type:

- **function**

Arguments:

- **string** `token|guid` _optional_

Returns: `number`

Returns the distance of the object to the token specified, or player if empty.

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:distance() < 3 then
	--Object is within 3 yards of the player.
end
```

## range

Type:

- **function**

Arguments:

- **string** `token|guid` _optional_

Returns: `boolean`

Returns true or false if the object is within 40 yards to the token specified, or player if empty.

```lua
local tar = ni.objects["target"];
if tar:exists() and tar:range() then
	--Object is within 40 yards of the player.
end
```

## creator

Type:

- **function**

Arguments:

Returns: `string`

Returns the GUID of the objects creator if they have one.

```lua
local tar = ni.objects["target"];
if tar:exists() then
	local creator = tar:creator();
	if creator then
		--The object has a creator, and now we have their GUID
	end
end
```

## target

Type:

- **function**

Arguments:

Returns: `string`

Returns the GUID of the objects target if they have one, otherwise "0x0000000000000000".

```lua
local tar = ni.objects["target"];
if tar:exists() then
	local target = tar:target();
	if UnitExists(target) then
		--The object has a target, and now we have their GUID
	end
end
```

## location

Type:

- **function**

Arguments:

Returns: `table`

Returns a table of the objects location along with their facing.

```lua
local tar = ni.objects["target"];
if tar:exists() then
	local location = tar:location();
	--Do something with the location.x, location.y, location.z and location.r of the object
end
```

---

> Another example of iterating the objects can be like what is within the fishing script. While iterating it this way, you can access all the above listed variables and functions the same. Example as follows:

```lua
local playerguid = UnitGUID("player");
for k, v in pairs(ni.objects) do
	if type(k) ~= "function" and (type(k) == "string" and type(v) == "table") then
		if v.name == "Fishing Bobber" then
			local creator = v:creator();
			if creator == playerguid then
				local ptr = ni.memory.objectpointer(v.guid);
				if ptr then
					local result = ni.memory.read("byte", ptr, offset);
					if result == 1 then
						ni.player.interact(v.guid);
						return true;
					end
				end
			end 
		end
	end
end
```
# Player

> All functions when used will be prepended with `ni.player`.

Apart from functions listed below, it's possible to call `ni.player` as a shorthand for calling any function in [Unit](api/unit.md) and passing `player` as the first argument.

```lua
ni.player.buff("Life Tap") -- Same as calling ni.unit.buff("player", "Life Tap")
ni.player.hp() -- Same as calling ni.unit.hp("player")
```

---

## clickat

Arguments:

- **unit** `token|guid|x,y,z|mouse`

Returns: `void`

Clicks at the specific location.

```lua
ni.player.clickat("target") --Clicks at the targets x/y/z
ni.player.clickat("mouse") --Clicks at the mouses current location
```

## hasglyph

Arguments:

- **glyph** `id`

Returns: `boolean`

Checks if a player has equipped a specific glyph.

```lua
if ni.player.hasglyph(42455) then
  -- Player has Glyph of Conflagrate
end
```

## hasitem

Arguments:

- **item** `id`

Returns: `boolean`

Checks if a player has a specific item.

```lua
if ni.player.hasitem(51378) then
  -- Player has item Medallion of the Horde
end
```

## hasitemequipped

Arguments:

- **item** `id`

Returns: `boolean`

Checks if a player has equipped a specific item.

```lua
if ni.player.hasitemequipped(51378) then
  -- Player has equipped item Medallion of the Horde
end
```

## interact

Arguments:

- **unit** `token|guid`

Returns: `void`

Interacts with the specified unit (e.g. opens a dialog with NPC, loot a container).

```lua
ni.player.interact("target")
```

## itemcd

Arguments:

- **slot** `id`

Returns: `number`

Checks if a specific inventory item is on cooldown and returns the remaining time.

```lua
if ni.player.itemcd(41119) > 0 then
  -- Saronite Bomb is on cooldown
end
```

## lookat

Arguments:

- **unit** `token|guid`
- **inv** `boolean` _default: false_

Returns: `void`

Looks in the direction of the unit. Can be inversed by passing `true` as second argument.

```lua
ni.player.lookat("target")
ni.player.lookat("target", true) --Looks away from the target
```

## moveto

Arguments:

- **unit** `token|guid|x,y,z`

Returns: `void`

Moves the player to specific target or coordinates.

```lua
ni.player.moveto("target")
```

## petcd

Arguments:

- **spell** `id|name`

Returns: `number`

Checks if a specific inventory item is on cooldown and returns the remaining time.

```lua
if ni.player.petcd("Devour Magic") > 0 then
  -- Devour Magic is on cooldown
end
```

## runtext

Arguments:

- **text** `string`

Returns: `void`

Runs the passed text as a macro.

```lua
ni.player.runtext("/s Hello") -- writes "Hello" to Say channel.
```

## slotcastable

Arguments:

- **slot** `id`

Returns: `boolean`

Checks if the players current slot is a castable spell or not.

```lua
if ni.player.slotcastable(10) then
  -- Player has a Spell on his hands (slot 10)
end
```

## slotcd

Arguments:

- **slot** `id`

Returns: `number`

Checks if a specific equipped slot is on cooldown and returns the remaining time.

```lua
if ni.player.slotcd(10) > 0 then
  -- Gloves on-use is on cooldown
end

if ni.player.slotcd(10) == 0 then
  -- Gloves on-use is off cooldown
end
```

## stopmoving

Arguments:

Returns: `void`

Stops all movement from the player.

```lua
ni.player.stopmoving()
```

## target

Arguments:

- **unit** `token|guid`

Returns: `void`

Sets the specified unit to be player's target.

```lua
ni.player.target("arena2")
```

## useinventoryitem

Arguments:

- **item** `id`

Returns: `void`

Uses the item from equipped items.

```lua
ni.player.useinventoryitem(10) -- Activates Gloves on-use
ni.player.useinventoryitem(13) -- Activates First Trinket slot
```

## useitem

Arguments:

- **item** `id|name`
- **target** `token|guid`

Returns: `void`

Uses the item from inventory. If unit is specified the item will be used on it.

```lua
ni.player.useitem(36892) -- Uses Healthstone
ni.player.useitem(36895, "focus") -- Places a Demonic Soulstone on focus
```

## movingfor

Arguments:

- **duration** `number`

Returns: `boolean`

Returns true or false if the player has been moving for the duration specified.

```lua
if ni.player.movingfor(2) then
	--The player has been moving for at least 2 seconds
end
```

## getmovingtime

Arguments:

Returns: `number`

Returns the moving time that the player has been moving for.

```lua
if ni.player.getmovingtime() > 60 then
	--The player has been moving for more than 60 seconds
end
```
# Power

> All functions when used will be prepended with `ni.power`.

If you only need to get unit's current power percent - there are two shorthand functions such as:

- [`ni.unit.power`](api/unit.md#power)
- [`ni.unit.powerraw`](api/unit.md#powerraw)
- [`ni.player.power`](api/player.md).
- [`ni.player.powerraw`](api/player.md).

By default power type will match specialization's current power type.

---

## current

Arguments:

- **unit** `guid|token`
- **type** `name|id`

Returns: `number`

Calculates unit's current power percent.

```lua
local power = ni.power.current("player") -- 90%
```

## currentraw

Arguments:

- **unit** `guid|token`
- **type** `name|id`

Returns: `number`

Calculates unit's current power.

```lua
local power = ni.power.currentraw("player") -- 20000 mana
```

## ismax

Arguments:

- **unit** `guid|token`
- **type** `name|id`

Returns: `boolean`

Checks if unit's power is at its maximum.

```lua
if ni.power.ismax("player") then
  -- Player's power is at 100%
end
```

## max

Arguments:

- **unit** `guid|token`
- **type** `name|id`

Returns: `number`

Calculates unit's maximum power.

```lua
local maxpower = ni.power.max("target")
```
# Rune

> All functions when used will be prepended with `ni.rune`.

---

## available

Arguments:

Returns: `number`

Calculates the number of available runes.

```lua
if ni.rune.available() == 6 then
  -- Player has all 6 runes available
end
```

## deathrunes

Arguments:

Returns: `number`

Calculates the number of death runes.

```lua
if ni.rune.deathrunes() == 4 then
  -- Player has 4 of their runes as death runes
end
```

## bloodrunecd

Arguments:

Returns: `number`, `number`

Returns the number of Blood Runes on and off cooldown.

```lua
local offcd, oncd = ni.rune.bloodrunecd()
  -- 1, 1 or 2, 0 or 0, 2
```

## deathrunecd

Arguments:

Returns: `number`, `number`

Returns the number of Death Runes on and off cooldown.

```lua
local offcd, oncd = ni.rune.deathrunecd()
  -- 1, 1 or 2, 0 or 0, 2
```

## frostrunecd

Arguments:

Returns: `number`, `number`

Returns the number of Frost Runes on and off cooldown.

```lua
local offcd, oncd = ni.rune.frostrunecd()
  -- 1, 1 or 2, 0 or 0, 2
```

## unholyrunecd

Arguments:

Returns: `number`, `number`

Returns the number of Unholy Runes on and off cooldown.

```lua
local offcd, oncd = ni.rune.unholyrunecd()
  -- 1, 1 or 2, 0 or 0, 2
```
# Spell

> All functions when used will be prepended with `ni.spell`.

---

## available

Arguments:

- **spell** `id|string`
- **stutter** `boolean` _default: true_

Returns: `boolean`

Checks if specified spell is available to use. Includes checks such as:

- [`ni.spell.gcd`](api/spell.md#gcd)
- [`ni.vars.combar.casting`](api/vars.md)
- [`ni.spell.cd`](api/spell.md#cd)
- [`ni.stopcastingtracker.shouldstop`](api/stopcasting.md)
- [`ni.player.powerraw`](api/player.md)
- [`ni.player.hpraw`](api/player.md)

!> [`ni.spell.available`](api/spell.md#available) is not the same as [`ni.spell.valid`](api/spell.md#valid).

```lua
if ni.spell.available("Fear") then
  -- Fear passess all the checks and is available
end
```

## cast

Arguments:

- **spell** `id|string`
- **target** `token|guid`

Returns: `void`

Casts the specified spell. If the target is provided it'll cast on that target, otherwise spell wll be casted on self.

```lua
ni.spell.cast("Shadow Bolt", "target")
```

## delaycast

Arguments:

- **spell** `id|string`
- **target** `token|guid`
- **delay** `number` _optional_

Returns: `boolean`

Just like cast, however you can specify delay, and if the time since it's last cast was over the delay, it'll cast the spell along with returning true. If it's under the delay, the function will return false.

```lua
if ni.spell.delaycast("Shadow Bolt", "target", 1.5) then
	--It's been more than 1.5 seconds since we last cast 1.5, so it cast
else
	--Spell did not cast because it's been less than 1.5 seconds since last cast
end
--Other usage just like normal cast, just to ensure it doesn't cast if under the delay time
if true then
	ni.spell.delaycast("Shadow Bolt", "target", 1.5)
end
```

## bestaoeloc

- **distance** `number`
- **radius** `number`
- **friendly** `boolean` _optional_
- **minimumcount** `number` _optional_
- **inc** `number` _optional_
- **zindex_inc** `number` _optional_

Returns: `X/Y/Z`

This function uses the internal check for sweeping around the player to search for the best X/Y/Z coordinate to place an AoE at. The distance and radius are the only two required, the rest are optional. Friendly is to check for units you can assist if true, or that you can attack if false (default: false). minimumcount is the minimum number of units within the radius to be counted as a good location (default: 2). inc is for the incremental looping that is done, the higher the number the less efficient the scan is, but the quicker it is done; for example if a distance of 30 is passed and the increment is 1.5 it would go -30, -28.5, -27, -25.5 ... to +30 (default: 1). zindex_inc is for the readjustment to obtain a new Z for each position checked, meaning the point where the ground actually is, each point uses +increment and -increment from the players Z and uses the hit location as the new z (default: 20).

```lua
local x, y, z = ni.spells.bestaoeloc(30, 4, false, 6);
--This would return nil if there is no good location, otherwise x, y, z will be the best location to hit at least 6 mobs within a location that is at least 30 yards from the player and has a splash radius of 4 yards
```

## castharmfulatbest

- **spell** `id|string`
- **distance** `number`
- **radius** `number`
- **minimumcount** `number` _optional_
- **inc** `number` _optional_
- **zindex_inc** `number` _optional_

Returns: `void`

This function will cast the spell specified at the best location matching the requirements. See above for what each argument is.

```lua
ni.spell.cast("Hurricane", 36, 4, 4); --On a druid this would cast hurricane at the best location within 36 yards of the player that has at least 4 mobs to be hit
```

## casthelpfulatbest

- **spell** `id|string`
- **distance** `number`
- **radius** `number`
- **minimumcount** `number` _optional_
- **inc** `number` _optional_
- **zindex_inc** `number` _optional_

Returns: `void`

This function will cast the spell specified at the best location matching the requirements. See above for what each argument is.

```lua
ni.spell.cast("Healing Rain", 36, 4, 5); --On a shaman this would cast healing rain at the best location within 36 yards of the player that has at least 5 friendlies to be hit by the heal
```

## castat

Arguments:

- **spell** `id|string`
- **target** `token|guid|mouse`
- **offset** `number`

Returns: `void`

Casts specified spell which required click on the ground (e.g. Death and Decay, Rain of Fire, Blizzard).

```lua
ni.spell.castat("Rain of Fire", "target")
```

## castatqueue

Arguments:

- **spell** `id|string`
- **target** `token|guid|mouse`

Returns: `void`

Queues a specified spell to be casted on the ground once it's available.

```lua
ni.spell.castatqueue("Blizzard", "target")
```

## castqueue

Arguments:

- **spell** `id|string`
- **target** `token|guid`

Returns: `void`

Queues a specified spell to be casted once it's available.

```lua
ni.spell.castqueue("Fear", "target")
```

## castspells

Arguments:

- **spell** `id|string`
- **target** `token|guid`

Returns: `void`

Casts specified spells separated by pipe (`|`). If the target is provided it'll cast on that target, otherwise spells wll be casted on self. Does not work if spells more than one spell triggers global cooldown.

```lua
ni.spell.castspells("Heroic Strike|Bloodthirst", "target")
```

## casttime

Arguments:

- **spell** `id|string`

Returns: `number`

Calculates the cast time of specified spell.

```lua
local casttime = ni.spell.casttime("Immolate") -- 1.25
```

## cd

Arguments:

- **spell** `id|string`

Returns: `number`

Calculates specified spell's cooldown. If the spell is not on cooldown returns 0.

```lua
if not ni.spell.cd(47891) then
  -- Shadow Ward is not on cooldown
end
```

## gcd

Arguments:

Returns: `boolean`

Checks if global cooldown is triggered.

```lua
if not ni.spell.gcd() then
  -- Global cooldown is not active, we can do something
end
```

## id

Arguments:

- **spellname** `string`

Returns: `number|nil`

Converts spell's name into spell id. If spell doesn't exist returns nil.

```lua
local spellid = ni.spell.id("Life Tap") -- 57946
```

## isinstant

Arguments:

- **spell** `string|id`

Returns: `boolean`

Checks if passed spell is instant cast.

```lua
if ni.spell.isinstant(57946) then
  -- Life Tap is instant spell
end
```

## stopcasting

Arguments:

Returns: `void`

Stops casting.

```lua
ni.spell.stopcasting()
```

## stopchanneling

Arguments:

Returns: `void`

Stops channeling.

```lua
ni.spell.stopchanneling()
```

## valid

Arguments:

- **spell** `id|string`
- **target** `token|guid`
- **facing** `boolean` _default: false_
- **los** `boolean` _default: false_
- **friendly** `boolean` _default: false_

Returns: `boolean`

This functions ensures that a spell can be casted at specific target. It includes checks such as:

!> [`ni.spell.valid`](api/spell.md#valid) is not the same as [`ni.spell.available`](api/spell.md#available).

- [`ni.unit.exists`](api/unit.md#exists)
- [`ni.player.los`](api/player.md)
- [`ni.player.isfacing`](api/player.md)

```lua
if ni.spell.valid("Fear", "target") then
  -- Fear meets all of the critera to be valid
end
```
# Unit

> All functions when used will be prepended with `ni.unit`.

---

## aura

Arguments:

- **unit** `guid|token`
- **aura** `id|name`

Returns: `boolean`

Checks if specified unit has aura (this check is more than wow's UnitAura as it can return true for passive auras not seen by the normal client).

```lua
if ni.unit.aura("player", 32223) then
  -- Player has Crusader Aura
end
if ni.unit.aura("player", "Crusader Aura") then
	--Player has Crusader Aura
end
```

## auras

Arguments:

- **unit** `guid|token`

Returns: `table`

Returns a table of all the auras on the unit with their ID and name (able to see auras that are not normally seen by the client with this, this function is more for developers to get a list of all auras on a unit to use with the aura function).

```lua
local auras = ni.unit.auras("target");
for k, v in ipairs(auras) do
	if v.name == "Crusader Aura" then
		--The unit has the aura Crusader Aura by name check
	end
	if v.ID == 32223 then
		--The unit has the aura Crusader Aura by ID check
	end
end
```

## buff

Arguments:

- **target** `guid|token`
- **id** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `UnitBuff`

Checks if specified unit has certain buff.

```lua
if ni.unit.buff("target", "Life Tap", "player") then
  -- Target has Life Tap active
end
if ni.unit.buff("player", 533, "exact") then
  -- Player has the buff that exactly matches ID 533
end
```

## buffremaining

Arguments:

- **target** `guid|token`
- **id** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `boolean`

Calculates the remaining time of the buff on target in seconds.

```lua
if ni.unit.buffremaining("target", 48441, "player") < 5 then
  -- Target has Rejuvenation for less than 5 seconds
end
```

## buffstacks

Arguments:

- **target** `guid|token`
- **id** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `number`

Obtains the number of buff stacks on target.

```lua
if ni.unit.buffstacks("target", 1234) < 5 then
  -- Target has less than 5 stacks of 1234 on them
end
```

## buffs

Arguments:

- **target** `guid|token`
- **ids** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `boolean`

Checks if specified unit has certain buffs separated by `&&` or `||`.

```lua
if ni.unit.buffs("target", "63321&&Fel Armor", "player") then
  -- Target has both Life Tap and Fel Armor
end
if ni.unit.buffs("target", "63321||Fel Armor") then
  -- Target has either Life Tap, or Fel Armor
end
```

## bufftype

Arguments:

- **target** `guid|token`
- **types** `string|string`

Returns: `boolean`

Checks if specified unit has certain buff types. Multiple types can be passed by using the pipe character (`|`).

| Type   |
| ------ |
| Magic  |
| Enrage |

```lua
if ni.unit.bufftype("target", "Enrage|Magic") then
        -- Target has either a Enrage or Magic debuff present
end
```

## combatreach

Arguments:

- **target** `guid|token`

Returns: `number`

The combat reach of the unit checked (default return of 0).

```lua
local combatreach = ni.unit.combatreach("player");
-- Would most likely print 1.5 as the combat reach of the player unit
```

## creations

Arguments:

- **target** `guid|token`

Returns: `table|nil`

Table of all the units checked creations (i.e. totems, pets) or nil if there is none.

```lua
local creations = ni.unit.creations("player");

for i = 1, #creations do
  local creature = creations[i]
  -- Do something
end
```

## creator

Arguments:

- **target** `guid|token`

Returns: `guid|nil`

Returns a `guid` if specified unit has a creator or `nil` if it doesn't.

```lua
local creator = ni.unit.creator("playerpet");

if UnitGUID("player") == creator then
  -- We're the creator of the checked unit
end
```

## creaturetype

Arguments:

- **target** `guid|token`

Returns: `number`

Numerical type of the unit checked.

| Numeric | String       |
| ------- | ------------ |
| 0       | Unknown      |
| 1       | Beast        |
| 2       | Dragon       |
| 3       | Demon        |
| 4       | Elemental    |
| 5       | Giant        |
| 6       | Undead       |
| 7       | Humanoid     |
| 8       | Critter      |
| 9       | Mechanical   |
| 10      | NotSpecified |
| 11      | Totem        |
| 12      | NonCombatPet |
| 13      | GasCloud     |

```lua
local type = ni.unit.creaturetype("playerpet")

if type == 3 then
  --Our pet is a demon
end
```

## debuff

Arguments:

- **target** `guid|token`
- **id** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `UnitDebuff`

Checks if specified unit has certain debuff.

```lua
if ni.unit.debuff("target", "Unstable Affliction", "player") then
  -- Target has Unstable Affliction
end
if ni.unit.debuff("target", 1234, "exact|player") then
  -- Target has debuff matching the spell ID 1234 cast by the player
end
```

## debuffstacks

Arguments:

- **target** `guid|token`
- **id** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `number`

Obtains the number of debuff stacks on target.

```lua
if ni.unit.debuffstacks("target", 1234) < 5 then
  -- Target has less than 5 stacks of 1234 on them
end
```

## debuffremaining

Arguments:

- **target** `guid|token`
- **id** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `boolean`

Calculates the remaining time of the debuff on target in seconds.

```lua
if ni.unit.debuffremaining("target", 1234, "player") < 5 then
  -- Target has spell of ID 1234 for less than 5 seconds
end
```

## debuffs

Arguments:

- **target** `guid|token`
- **ids** `name|id`
- **filter** `EXACT|PLAYER` _optional_

Returns: `boolean`

Checks if specified unit has certain debuffs separated by `&&` or `||`.

```lua
if ni.unit.debuffs("target", "Faerie Fire&&Curse of Agony", "player") then
  -- Target has both Faerie Fire and Curse of Agony
end
if ni.unit.debuffs("target", "Faerie Fire||Curse of Agony") then
  -- Target has either Faerie Fire or Curse of Agony
end
```

## debufftype

Arguments:

- **target** `guid|token`
- **types** `string|string`

Returns: `boolean`

Checks if specified unit has certain debuff types. Multiple types can be passed by using the pipe character (`|`).

| Type    |
| ------- |
| Magic   |
| Poison  |
| Curse   |
| Disease |

```lua
if ni.unit.debufftype("target", "Poison|Magic") then
        -- Target has either a poison or magic debuff present
end
```

## distance

Arguments:

- **unit** `guid|token`
- **target** `guid|token`

Returns: `number|nil`

Calculates the distance between `unit` and `target` in yards. If any of the arguments are not passed this function will return `nil`.

```lua
if ni.unit.distance("player", "target") < 40 then
  -- Target is closer than 40 yards
end
```

## enemiesinrange

Arguments:

- **unit** `guid|token`
- **range** `number`

Returns: `table`

Returns a table of all enemies which are in range of specified unit. Each enemy has `guid`, `name` and `distance` properties.

```lua
local enemies = ni.unit.enemiesinrange("player", 30)

for i = 1, #enemies do
  local target = enemies[i].guid
  local name = enemies[i].name
  local distance = enemies[i].distance
  -- Do something with the enemy target
end
```

## exists

Arguments:

- **target** `guid|token`

Returns: `boolean`

Checks if specified unit exists in viewable world. If you want to check if unit exists overall, you can use WoW's `UnitExists` function.

```lua
if ni.unit.exists("target") then
  -- Do something
end
```

## friendsinrange

Arguments:

- **unit** `guid|token`
- **range** `number`

Returns: `table`

Returns a table of all friendlies which are in range of specified unit. Each friendly has `guid`, `name` and `distance` properties.

```lua
local friends = ni.unit.friendsinrange("player", 30)

for i = 1, #friends do
  local target = friends[i].guid
  local name = friends[i].name
  local distance = friends[i].distance
  -- Do something with the friendly target
end
```

## hasheal

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if specified unit has heals. This doesn't mean that the unit is necessarily a healer.

```lua
if ni.unit.hasheal("target") then
  -- Unit has heals
end
```

## hp

Arguments:

- **unit** `guid|token`

Returns: `number`

Calculates and returns current percent of the unit's health.

```lua
if ni.unit.hp("target") > 90 then
  -- Unit has more than 90% hp
end
```

## hppredicted

Arguments:

- **unit** `guid|token`

Returns: `number`

Supported: `4.3.4` and `5.4.8`

Calculates and returns predicted unit's health. It calculates current health with incoming heal and calculates the percent.

```lua
if ni.unit.hppredicted("target") < 30 > then
  -- Unit will have less than 30% after getting healed
end
```

## hpraw

Arguments:

- **unit** `guid|token`

Returns: `number`

Calculates and returns current unit's health.

```lua
if ni.unit.hpraw("target") > 20000 then
  -- Unit has more than 20k hp
end
```

## id

Arguments:

- **unit** `guid|token`

Returns: `number`

Retrieves unitd id.

```lua
if ni.unit.id("target") == 36597 then
  -- Unit is Lich King
end
```

## info

Arguments:

- **unit** `guid|token`

Returns: `number`

Retrieves detailed information about the unit.

```lua
local x, y, z, facing, unittype, target, height = ni.unit.info("target")
```

## inmelee

Arguments:

- **unit1** `token|guid`
- **unit2** `token|guid`

Returns: `boolean`

Checks if `unit1` is in melee range of `unit2`.

```lua
if ni.unit.inmelee("player", "target") then
  -- Target is in melee range of player
end
```

## isbehind

Arguments:

- **unit** `guid|token`
- **target** `guid|token`

Returns: `boolean`

Checks if `unit` is behind `target`.

```lua
if ni.unit.isbehind("player", "target") then
  -- Player is behind the target
end
```

## isboss

Arguments:

- **target** `guid|token`

Returns: `boolean`

Checks if specific unit is a boss.

```lua
if ni.unit.isboss("target") then
  -- Do something
end
```

## iscasting

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if specified unit is casting.

```lua
if ni.unit.iscasting("target") then
  -- Target is casting
end
```

## ischanneling

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if specified unit is channeling.

```lua
if ni.unit.ischanneling("target") then
  -- Target is channeling
end
```

## isdisarmed

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is disarmed.

```lua
if ni.unit.isdisarmed("target") then
  -- Target is disarmed
end
```

## isdummy

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks whether or not the unit is a dummy.

```lua
if ni.unit.isdummy("target") then
  -- Do something
end
```

## isfacing

Arguments:

- **unit** `guid|token`
- **target** `guid|token`
- **degrees** `number` _optional_

Returns: `boolean`

Checks if `unit` is facing `target`, degrees is defaulted to 180.

```lua
if ni.unit.isfacing("player", "target") then
  -- Player is facing the target
end
if ni.unit.isfacing("player", "target", 90) then
  -- Player is facing the target with a 90 degree precision (45 degrees both left and right)
end
```

## isfleeing

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is fleeing.

```lua
if ni.unit.isfleeing("target") then
  -- Target is fleeing
end
```

## isimmune

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit has immune flag.

```lua
if ni.unit.isimmune("target") then
  -- Target is immune
end
```

## islootable

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is lootable.

```lua
if ni.unit.islootable("target") then
  -- Target is lootable
end
```

## islooting

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is looting a container.

```lua
if ni.unit.islooting("target") then
  -- Target is looting
end
```

## ismounted

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is mounted.

```lua
if ni.unit.ismounted("target") then
  -- Target is mounted
end
```

## ismoving

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if unit is moving or not.

```lua
if ni.unit.ismoving("player") then
  -- Do something
end
```

## ispacified

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is pacified.

```lua
if ni.unit.ispacified("target") then
  -- Target is pacified
end
```

## isplayer

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is a player type.

```lua
if ni.unit.isplayer("target") then
  -- Target is a player type
end
```

## isplayercontrolled

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is controlled by a player.

```lua
if ni.unit.isplayercontrolled("target") then
  -- Target is controlled by player
end
```

## ispossessed

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit has possessed flag.

```lua
if ni.unit.ispossessed("target") then
  -- Target is possessed
end
```

## ispreparation

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit has Preparation flag.

```lua
if ni.unit.ispreparation("target") then
  -- Target has Preparation state
end
```

## ispvpflagged

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit has PvP flag enabled.

```lua
if ni.unit.ispvpflagged("target") then
  -- Target is PvP flagged
end
```

## issilenced

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit has silenced flag.

```lua
if ni.unit.issilenced("target") then
  -- Target is silenced
end
```

## isskinnable

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit has skinnable flag.

```lua
if ni.unit.isskinnable("target") then
  -- Target is skinnable
end
```

## isstunned

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit has stunned flag.

```lua
if ni.unit.isstunned("target") then
  -- Target is stunned
end
```

## istaggedbyme

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is tagged by player or group members.

```lua
if ni.unit.istaggedbyme("target") then
  -- Target is tagged by me
end
```

## istaggedbyother

Arguments:

- **unit** `guid|token`

Returns: `boolean`

Checks if passed unit is tagged by other.

```lua
if ni.unit.istaggedbyother("target") then
  -- Target is tagged by other
end
```

## istotem

Arguments:

- **target** `guid|token`

Returns: `boolean`

Checks whether the creature is a totem. Shorthand function for [creaturetype](api/unit.md#creaturetype).

```lua
if ni.unit.istotem("target") then
  -- Do something
end
```

## los

Arguments:

- **targetfrom** `guid|token|x,y,z`
- **targetto** `guid|token|x,y,z`
- **hitflags** `number` _optional_

Returns: `boolean, x, y, z`

Checks if units have line of sight on each other and returns the hit point of collision.

```lua
if ni.unit.los("player", "target") then
  -- Do something
end
local bool, x, y, z = ni.unit.los(100, 200, -10000, 100, 200, 10000);
if not bool then
	--We now have the z axis of collision from those points stored in the variable z`
end
```

## meleerange

Arguments:

- **unit1** `token|guid`
- **unit2** `token|guid`

Returns: `boolean`

Calculates melee range of `unit1` to `unit2`. If you want to check if unit is in melee range use [`inmelee`](api/unit.md#inmelee)

```lua
ni.unit.meleerange("player", "target")
```

## power

Arguments:

- **unit** `guid|token`
- **type** `string` _optional_

Returns: `number`

Calculates and returns current percent of the unit's power (e.g. mana, energy, focus, etc.).

```lua
if ni.unit.power("target") > 90 then
  -- Unit has more than 90% power
end
```

## powerraw

Arguments:

- **unit** `guid|token`
- **type** `string` _optional_

Returns: `number`

Calculates and returns current of unit's power (e.g. mana, energy, focus, etc.).

```lua
if ni.unit.powerraw("target") > 10000 then
  -- Unit has more than 10000 power
end
```

## readablecreaturetype

Arguments:

- **target** `guid|token`

Returns: `string`

Readable creature string of the unit checked.

| Numeric | String       |
| ------- | ------------ |
| 0       | Unknown      |
| 1       | Beast        |
| 2       | Dragon       |
| 3       | Demon        |
| 4       | Elemental    |
| 5       | Giant        |
| 6       | Undead       |
| 7       | Humanoid     |
| 8       | Critter      |
| 9       | Mechanical   |
| 10      | NotSpecified |
| 11      | Totem        |
| 12      | NonCombatPet |
| 13      | GasCloud     |

```lua
local type = ni.unit.readablecreaturetype("playerpet")

if type == "Demon" then
  -- Do something
end
```

## threat

Arguments:

- **unit** `guid|token`
- **unittargeted** `guid|token` _optional_

Returns: `number`

Calculates a threat of `unit`. If second argument is passed threat is calculated according to `unittargeted`.

```lua
local threat = ni.unit.threat("player", "target")
```

## ttd

Arguments:

- **unit** `guid|token`

Returns: `number`

Retrieves time to die of specified unit in seconds. If unit doesn't exist it returns `-2`, if the unit is a dummy or if the unit somehow skipped the ttd calculation returns `99`.

```lua
if ni.unit.ttd("target") > 10 then
  -- Do something
end
```

## unitstargeting

Arguments:

- **unit** `guid|token`
- **friendlies** `boolean` _default: false_

Returns: `table`

Returns a table of all units which are in range of specified unit. Each unit has `guid`, `name` and `distance` properties.

```lua
local units = ni.unit.unitstargeting("player")

for i = 1, #units do
  local target = units[i].guid
  local name = units[i].name
  local distance = units[i].distance
  -- Do something with the units targeting the player
end
```

## location

Arguments:

- **unit** `guid|token`

Returns: `x, y, z`

Returns value 1 being the units x, value 2 being the units y and value 3 being the units z.

```lua
local x, y, z = ni.unit.location("target");
--Do something with the x, y, and z'second
```

## transport

Arguments:

- **unit** `guid|token`

Returns: `string or nil`

Returns the GUID of the units transport if they have one (Like being on an elevator or vehicle, or unit on top of another unit), or nil.

```lua
local transport = ni.unit.transport("target")
if transport then
	--The target has a transport, maybe we need to kill that instead now?
end
```

## facing

Arguments:

- **unit** `guid|token`

Returns: `number`

Returns the units facing in radians.

```lua
if ni.unit.facing("target") == 0 then
	--The unit is facing true north
end
```

## LoS Bit Values

These are the following hit flags that can be passed to the los function if you don't want to use the default HitTestGroundAndStructures value.

```lua
HitTestNothing = 0x0,
HitTestBoundingModels = 0x1,
HitTestWMO = 0x10,
HitTestUnknown = 0x40,
HitTestGround = 0x100,
HitTestLiquid = 0x10000,
HitTestUnknown2 = 0x20000,
HitTestMovableObjects = 0x100000,
HitTestLOS = HitTestWMO | HitTestBoundingModels | HitTestMovableObjects,
HitTestGroundAndStructures = HitTestLOS | HitTestGround
```

To calculate a bitwise value you'd want, you can use wow's function bit.bor or just simply add the values.
```lua
local hit_ground_and_liquid = 0x100 + 0x10000;
if ni.unit.los("player", "target", hit_ground_and_liquid) then
	--Do because we didn't hit either ground or water
end
```
# Vars

> All variables when used will be prepended with `ni.vars`.

---

## general

```lua
ni.vars.latency -- interval between executing the rotation
ni.vars.interrupt -- could be `all` or `wl` or `bl`
ni.vars.build -- build version of currently running client
ni.vars.debug -- true/false to print when using ni.debug.print
ni.vars.customtarget -- token or guid of custom target
```

## hotkeys

```lua
ni.vars.hotkeys.aoe
ni.vars.hotkeys.cd
ni.vars.hotkeys.pause
ni.vars.hotkeys.custom
```

## profiles

```lua
ni.vars.profiles.primary --Name of the primary profile
ni.vars.profiles.secondary --Name of the secondary profile
ni.vars.profiles.active --Name of the active profile
ni.vars.profiles.generic --Name of the generic profile
ni.vars.profiles.genericenabled --Generic profile is enabled
ni.vars.profiles.interrupt --Interrupt engine is enabled
ni.vars.profiles.enabled --Active profile is enabled
ni.vars.profiles.useEngine --Enables/Disables the members table
ni.vars.profiles.delay --Time to delay the profile execution until (should not be set via the variable itself)
```

## units

```lua
ni.vars.units.follow
ni.vars.units.followEnabled
ni.vars.units.mainTank
ni.vars.units.mainTankEnabled
ni.vars.units.offTank
ni.vars.units.offTankEnabled
```

## combat

```lua
ni.vars.combat.started -- true/false for when player regen enabled/disabled (combat)
ni.vars.combat.time -- time since combat started
ni.vars.combat.melee -- true/false for deciding movement using follow feature
ni.vars.combat.cd -- true/false for cooldown toggle enabled
ni.vars.combat.aoe -- true/false for aoe toggle enabled
ni.vars.combat.casting --  true/false for spell sent to server
```
-------------------------------------------
-- This is an Example, Filename: general.lua
-------------------------------------------
local enables = {
	["povorot"] = false,
    ["spam"] = false,
    ["inchant"] = false,
}
local values = {
    ["inchant"] = 179,
    ["spam"] = 1,
    ["glaz"] = 0,
    ["frame"] = 41,
}
local inputs = {
    pool = "",
}
local menus = {
}
local function GUICallback(key, item_type, value)
	if item_type == "enabled" then
		enables[key] = value;
	elseif item_type == "value" then
		values[key] = value;
	elseif item_type == "input" then
		inputs[key] = value;
	elseif item_type == "menu" then
		menus[key] = value;
	end
end
local items = {
    settingsfile = "general.json",
    callback = GUICallback,
    { type = "title", text = "General Profile by |c0000CED1Makaren|r" },
	{ type = "separator" },
    { type = "page", number = 1, text = "|cffFFFF00Доп настройки игры|r" },
    { type = "separator" },
    { type = "entry", text = ni.spell.icon(24803).." Доп отдаление камеры", tooltip ="Отдаляет камеру путем рыбьего глаза", value = 0, min = 0, max = 100, step = 1, key = "glaz" },
    { type = "separator" },
    { type = "entry", text = ni.spell.icon(24803).." Дальность отображения фреймов", tooltip ="Меняет дальносить отображения фреймов(Default: 41)", value = 41, min = 0, max = 10000, width = 50, step = 1, key = "frame" },
    { type = "page", number = 2, text = "|cffFFFF00Автоповорот|r" },
    { type = "separator" },
    { type = "entry", text = ni.spell.icon(24803).." Автоповорот", tooltip ="Автоматически поворачивается к таргету", enabled = false, key = "povorot" },
    { type = "title", text = "|cFFFF0000Использовать на свой страх и риск!|r"},
    { type = "page", number = 3, text = "|cffFFFF00Хелпер|r" },
    { type = "separator" },
    { type = "entry", text = ni.spell.icon(13262).." Авто распыление предметов", tooltip ="Если поле ввода пустое то атоматически распыляет предметы уровня ниже", enabled = false, value = 179, min = 1, max = 300, step = 1, key = "inchant" },
    {
		type = "input",
		value = inputs["pool"],
		width = 140,
		height = 15,
		key = "pool"
	},
    { type = "page", number = 4, text = "|cffFFFF00Автоспам|r" },
    { type = "separator" },
    { type = "entry", text = ni.spell.icon(24803).." Автосмап макроса", tooltip ="Автоматически спамит макрос", enabled = false,  key = "spam" },
    { type = "entry", text =" Частота", tooltip ="Частота спама в минутах", value = 1,  key = "spam" },
    { type = "separator" },
    { type = "title", text = "Для того чтобы автоспам работал, нужно создать макрос с именем makaren"},

}
local function OnLoad()
	ni.GUI.AddFrame("general", items);
end;
local function OnUnLoad()  
	ni.GUI.DestroyFrame("general");
end;
local cache = {
    IsMoving = false,
    hours = false,
    minutes = false,
    hours_ = false,
    minutes_ = false,
    time = false,
    i = 1,
    ii = 0,
    i_ = 1,
    ii_ = 0,
    text = "/use",
    glaz = 0,
    frame = 41,
}
local queue = {
    "cache",
    "glaz",
    "frame",
    "povorot",
    "inchant",
    "spam",
}
local abilities = {
    ["cache"] = function()
        cache.IsMoving = ni.player.ismoving() or false;
        if cache.ii == 5 then
            cache.ii = 0
        end
        if cache.i == 30 then
            cache.i = 1
            cache.ii = cache.ii + 1
        end
    end,
    ["glaz"] = function()
        if values["glaz"] ~= cache.glaz then
            local text = (string.format('/run SetCVar("cameraFov",  %s', values["glaz"]+100))
            local text = (string.format(text .. "%s", ")"))
            ni.player.runtext(text)
            cache.glaz = values.glaz
        end
    end,
    ["frame"] = function()
        if values["frame"] ~= cache.frame then
            local text = (string.format('/run SetCVar("nameplateDistance",  %s', values["frame"]))
            local text = (string.format(text .. "%s", ")"))
            ni.player.runtext(text)
            cache.frame = values.frame
        end
    end,
    ["povorot"] = function()
        if enables["povorot"] 
        and not cache.IsMoving then
            ni.player.lookat("target")
        end
    end,
    ["inchant"] = function()
        if enables["inchant"]
        and inputs.pool == "" then
            local ItemLink = GetContainerItemLink(cache.ii, cache.i)
            local itemName, itemLink, itemRarity, itemLevel, itemMinLevel, itemType,
            itemSubType, itemStackCount, itemEquipLoc, itemTexture, itemSellPrice = GetItemInfo(ItemLink)
            cache.i_ = tostring(cache.i)
            cache.ii_ = tostring(cache.ii)
            local text = (string.format("/use %s", cache.ii_))
            cache.text = (string.format(text .. " %s", cache.i_))
            cache.i = cache.i + 1
            if itemLevel <= values["inchant"]
            and ni.spell.available(13262) then
                if itemType == "Оружие" 
                or itemType == "Доспехи" then
                    ni.spell.cast(13262)
                    ni.player.runtext(cache.text)
                end
            end
        elseif enables["inchant"] then
            local ItemLink = GetContainerItemLink(cache.ii, cache.i)
            local itemName, itemLink, itemRarity, itemLevel, itemMinLevel, itemType,
            itemSubType, itemStackCount, itemEquipLoc, itemTexture, itemSellPrice = GetItemInfo(ItemLink)
            cache.i_ = tostring(cache.i)
            cache.ii_ = tostring(cache.ii)
            local text = (string.format("/use %s", cache.ii_))
            cache.text = (string.format(text .. " %s", cache.i_))
            cache.i = cache.i + 1
            if itemName == inputs.pool
            and ni.spell.available(13262) then
                if itemType == "Оружие" 
                or itemType == "Доспехи" then
                    ni.spell.cast(13262)
                    ni.player.runtext(cache.text)
                end
            end
        end
    end,
    ["spam"] = function()
        if enables["spam"] then
            hours,minutes = GetGameTime();
            cache.hours = hours
            cache.minutes = minutes
            if cache.hours_ == false then
                cache.hours_ = hours
                cache.minutes_ = minutes
            end
            if cache.hours == cache.hours_ then
                cache.time = cache.minutes - cache.minutes_
                if cache.time >= values["spam"] then
                    RunMacro("makaren")
                    cache.hours_ = false
                end
            else 
                cache.time = cache.minutes - cache.minutes_ + 60
                if cache.time >= values["spam"] then
                    RunMacro("makaren")
                    cache.hours_ = false
                end
            end
        end
    end,
}
ni.bootstrap.profile("general", queue, abilities, OnLoad, OnUnLoad);
----------------------------------------------
--end of file. Filename: general.lua
-----------------------------------------------

---------------------------------------------
-- this is an example, filename: GUIexample.lua
-----------------------------------------

-- Try to localize standart WoW Api and other Lua stuff for faster work
local UnitLevel, ipairs, pairs, tostring, GetTime, print = UnitLevel, ipairs, pairs, tostring, GetTime, print
-- Call and draw GUI;
local items1 = {
	settingsfile = "GUIExample.json", -- Add name for file with settings from GUI;
	{ type = "title", text = "Example GUI" }, -- Call title; 
	{ type = "separator" }, -- Call line ("seperator");
	{ type = "entry", text = ni.spell.icon(59646).." Perform Action", tooltip = "Enable for Auto pick-up healthstoneuse from soulwell", enabled = false, value = 2, min = 1.5, max = 10, step = .5, width = 40, key = "Action" },	-- Call entry with field;
	{ type = "title", text = "Input what to print after the action" },
	{ type = "input", value = "", width = 225, height = 65, wordwrap = true, key = "WhatToPrint" }, -- wordwrap - not nessesary 
	{ type = "title", text = "What do you want to do?" },
	{ type = "dropdown", menu = { -- draw dropdown menu
		{ selected = true, value = 1, text = "Jump" },
		{ selected = false, value = 2, text = "Move Forward" },
		{ selected = false, value = 3, text = "Move Backward" },
		{ selected = false, value = 4, text = "Strafe Right" },
        { selected = false, value = 5, text = "Strafe Left" },
	}, key = "ActionEvent" },
};
-- Call and draw GUI #2;
local items2 = {
	settingsfile = "GUIExampleLow.json", -- Add name for file with settings from GUI;
	{ type = "title", text = "Example GUI Low Level" }, -- Call title; 
	{ type = "separator" }, -- Call line ("seperator");
	{ type = "entry", text = ni.player.itemicon(21353).." Perform Action", tooltip = "Enable for Auto pick-up healthstoneuse from soulwell", enabled = false, value = 3, min = 1.5, max = 10, step = .5, width = 40, key = "Action" },	-- Call entry with field;
};
-- You can call multiply GUI's (GUI only loads when you enter the game or /reload)
local function items()
	if UnitLevel("player") >= 80 then
		return items1
	else
		return items2
	end
end;
-- Call Settings from GUI;
local function GetSetting(name)
    for k, v in ipairs(items()) do
        if v.type == "entry"
		and v.key ~= nil
		and v.key == name then
            return v.value, v.enabled;
        end
        if v.type == "dropdown"
		and v.key ~= nil
		and v.key == name then
            for k2, v2 in pairs(v.menu) do
                if v2.selected then
                    return v2.value;
                end
            end
        end
        if v.type == "input"
		and v.key ~= nil
		and v.key == name then
            return v.value;
        end
    end
end;
-- Load GUI when turn on profile;
local function OnLoad()
	ni.GUI.AddFrame("GUIExample", items());
end;
-- Unload GUI when turn off profile;
local function OnUnLoad() 
	ni.GUI.DestroyFrame("GUIExample");
end;
-- Call queue table
local queue = {
	"action",
};
local last_action = 0;
-- Call abilities table
local abilities = {
	["action"] = function()
		local value, enabled = GetSetting("Action");
		local event = GetSetting("ActionEvent");
		local text = tostring(GetSetting("WhatToPrint"));
		if enabled then
			if GetTime() - last_action > value then
				last_action = GetTime();
				if event == 1 then
					ni.functions.callprotected("JumpOrAscendStart");
					if text ~= "" then
						print(text)
					end
				elseif event == 2 then
					ni.functions.callprotected("MoveForwardStart");
					ni.delayfor(0.5, function()
							ni.functions.callprotected("MoveForwardStop")
							if text ~= "" then
								print(text)
							end
						end);
					ni.rotation.delay(1);
				elseif event == 3 then
					ni.functions.callprotected("MoveBackwardStart");
					ni.delayfor(0.5, function()
							ni.functions.callprotected("MoveBackwardStop")
							if text ~= "" then
								print(text)
							end
						end);
					ni.rotation.delay(1);
				elseif event == 4 then
					ni.functions.callprotected("StrafeRightStart");
					ni.delayfor(0.5, function()
							ni.functions.callprotected("StrafeRightStop")
							if text ~= "" then
								print(text)
							end
						end);
					ni.rotation.delay(1);
				elseif event == 5 then
					ni.functions.callprotected("StrafeLeftStart");
					ni.delayfor(0.5, function()
							ni.functions.callprotected("StrafeLeftStop")
							if text ~= "" then
								print(text)
							end
						end);
					ni.rotation.delay(1);
				end
			end
		end
	end,
};
ni.bootstrap.profile("GUIExample", queue, abilities, OnLoad, OnUnload);

----------------------------------
-- end of example file, filename GUIexample.lua
----------------------------------

--------------------------------
-- this is an example, filename: Restro_Wrath.lua
-- restoration shaman
-- wrath of the lich king
-- patch 3.3.5a
------------------------------------
local build = select(4, GetBuildInfo());
local wotlk = build == 30300 or false;
if wotlk then

local queue = {
	"Pause",
	"CancelCast",
	"WaterShield",
	"EarthlivingWeapon",
	"Tank Heal",
	"Riptide",
	"ChainHeal",
	"HealingWave",
	"LesserHealingWave",
	"LightningBolt"
}
local enables = {
	["RiptideTank"] = true,
	["LesserHealingWaveTank"] = true,
	["HealingWaveTank"] = true,
	["LightningBolt"] = false,
	["TargetUnit"] = false,
	["CancelCast"] = false
}
local values = {
	["RiptideTank"] = 92,
	["LesserHealingWaveTank"] = 20,
	["HealingWaveTank"] = 75,
	["RiptideHP"] = 92,
	["LesserHealingWave"] = 20,
	["HealingWaveHP"] = 60,
	["ChainHealHP"] = 75,
	["CancelCast"] = 95
}
local inputs = {}
local mainTankText, offTankText, focusText = "|cffFFFF33Main Tank", "|cffFF9900Off Tank", "|cff24E0FBFocus"

local menus = {
	["EarthShieldTar"] = 1
}
local function GUICallback(key, item_type, value)
	if item_type == "enabled" then
		enables[key] = value
	elseif item_type == "value" then
		values[key] = value
	elseif item_type == "input" then
		inputs[key] = value
	elseif item_type == "menu" then
		menus[key] = value
	end
end
local items = {
	settingsfile = "Restro_Wrath.xml",
	callback = GUICallback,
	{type = "title", text = "Restro_Wrath"},
	{type = "separator"},
	{type = "title", text = "Earth Shield Target"},
	{
		type = "dropdown",
		menu = {
			{selected = (menus["EarthShieldTar"] == 1), value = 1, text = mainTankText},
			{selected = (menus["EarthShieldTar"] == 2), value = 2, text = offTankText},
			{selected = (menus["EarthShieldTar"] == 3), value = 3, text = focusText}
		},
		key = "EarthShieldTar"
	},
	{type = "separator"},
	{type = "title", text = "Tank Heal"},
	{
		type = "entry",
		text = "Riptide Tank HP",
		enabled = enables["RiptideTank"],
		value = values["RiptideTank"],
		key = "RiptideTank"
	},
	{
		type = "entry",
		text = "Healing Wave Tank HP",
		value = values["HealingWaveTank"],
		enabled = enables["HealingWaveTank"],
		key = "HealingWaveTank"
	},
	{
		type = "entry",
		text = "Lesser Healing Wave Tank HP",
		value = values["LesserHealingWaveTank"],
		enabled = enables["LesserHealingWaveTank"],
		key = "LesserHealingWaveTank"
	},
	{type = "separator"},
	{type = "title", text = "Heals"},
	{
		type = "entry",
		text = "Riptide HP",
		value = values["RiptideHP"],
		key = "RiptideHP"
	},
	{
		type = "entry",
		text = "Lesser Healing Wave",
		value = values["LesserHealingWave"],
		key = "LesserHealingWave"
	},
	{
		type = "entry",
		text = "Healing Wave HP",
		value = values["HealingWaveHP"],
		key = "HealingWaveHP"
	},
	{
		type = "entry",
		text = "Chain Heal HP",
		value = values["ChainHealHP"],
		key = "ChainHealHP"
	},
	{type = "title", text = "Dps"},
	{
		type = "entry",
		text = "Use Lightning Bolt",
		enabled = enables["LightningBolt"],
		key = "LightningBolt"
	},
	{type = "separator"},
	{type = "title", text = "Other"},
	{
		type = "entry",
		text = "Target Units",
		enabled = enables["TargetUnit"],
		key = "TargetUnit"
	},
	{
		type = "entry",
		text = "Cancel Cast",
		enabled = enables["CancelCast"],
		value = values["CancelCast"],
		key = "CancelCast"
	}
}

local incombat = false
local function CombatEventCatcher(event, ...)
	if event == "PLAYER_REGEN_DISABLED" then
		incombat = true
	elseif event == "PLAYER_REGEN_ENABLED" then
		incombat = false
	end
end
local function OnLoad()
	ni.combatlog.registerhandler("RestroMOP", CombatEventCatcher)
	ni.GUI.AddFrame("RestroMOP", items)
end
local function OnUnload()
	ni.combatlog.unregisterhandler("RestroMOP")
	ni.GUI.DestroyFrame("RestroMOP")
end

local temptable = {}
local customtable = {}
local function SortByUnits(x, y)
	return x.unitsclose > y.unitsclose
end
local function SortByHP(x, y)
	return x.hp < y.hp
end
local function GetTableForBestUnit(health, distance, unitsclose, buff)
	table.wipe(customtable)
	for i = 1, #ni.members do
		if
			ni.members[i].hp <= health and ni.members[i].range and
				(buff ~= nil and not ni.unit.buff(ni.members[i].unit, buff, "player"))
		 then
			table.wipe(temptable)
			if buff ~= nil then
				temptable = ni.members.inrangewithoutbuff(ni.members[i].unit, distance, buff, "player")
				for k, v in ipairs(temptable) do
					if v and v.hp > health then
						tremove(temptable, k)
					end
				end
			else
				temptable = ni.members.inrangebelow(ni.members[i].unit, distance, health)
			end
			if #temptable >= unitsclose then
				tinsert(customtable, {unit = ni.members[i].unit, hp = ni.members[i].hp, unitsclose = #temptable})
			end
		end
	end
	if #customtable > 0 then
		table.sort(customtable, SortByHP)
	end
end

local spells = {
	--General
	GiftoftheNaaru = {id = 59547, name = GetSpellInfo(59547)},
	AutoAttack = {id = 6603, name = GetSpellInfo(6603)},
	--Elemental Combat
	WindShear = {id = 57994, name = GetSpellInfo(57994)},
	EarthbindTotem = {id = 2484, name = GetSpellInfo(2484)},
	StoneclawTotem = {id = 10428, name = GetSpellInfo(10428)},
	MagmaTotem = {id = 25552, name = GetSpellInfo(25552)},
	FrostShock = {id = 10473, name = GetSpellInfo(10473)},
	CalloftheElements = {id = 66842, name = GetSpellInfo(66842)},
	SearingTotem = {id = 10438, name = GetSpellInfo(10438)},
	FlameShock = {id = 29228, name = GetSpellInfo(29228)},
	CalloftheAncestors = {id = 66843, name = GetSpellInfo(66843)},
	LightningBolt = {id = 25448, name = GetSpellInfo(25448)},
	FireNova = {id = 25546, name = GetSpellInfo(25546)},
	Purge = {id = 8012, name = GetSpellInfo(8012)},
	ChainLightning = {id = 25439, name = GetSpellInfo(25439)},
	CalloftheSpirits = {id = 66844, name = GetSpellInfo(66844)},
	EarthShock = {id = 10414, name = GetSpellInfo(10414)},
	--Enhancement
	FrostResistanceTotem = {id = 10479, name = GetSpellInfo(10479)},
	FlametongueWeapon = {id = 25489, name = GetSpellInfo(25489)},
	GhostWolf = {id = 2645, name = GetSpellInfo(2645)},
	FireResistanceTotem = {id = 10538, name = GetSpellInfo(10538)},
	WindfuryTotem = {id = 8512, name = GetSpellInfo(8512)},
	WrathofAirTotem = {id = 3738, name = GetSpellInfo(3738)},
	LightningShield = {id = 25469, name = GetSpellInfo(25469)},
	FrostbrandWeapon = {id = 25500, name = GetSpellInfo(25500)},
	SentryTotem = {id = 6495, name = GetSpellInfo(6495)},
	WindfuryWeapon = {id = 16362, name = GetSpellInfo(16362)},
	WaterWalking = {id = 546, name = GetSpellInfo(546)},
	EarthElementalTotem = {id = 2062, name = GetSpellInfo(2062)},
	StoneskinTotem = {id = 25508, name = GetSpellInfo(25508)},
	StrengthofEarthTotem = {id = 25528, name = GetSpellInfo(25528)},
	FlametongueTotem = {id = 16387, name = GetSpellInfo(16387)},
	WaterBreathing = {id = 131, name = GetSpellInfo(131)},
	RockbiterWeapon = {id = 10399, name = GetSpellInfo(10399)},
	NatureResistanceTotem = {id = 10601, name = GetSpellInfo(10601)},
	AstralRecall = {id = 556, name = GetSpellInfo(556)},
	FarSight = {id = 6196, name = GetSpellInfo(6196)},
	GroundingTotem = {id = 8177, name = GetSpellInfo(8177)},
	--Restoration
	WaterShield = {id = 24398, name = GetSpellInfo(24398)},
	TremorTotem = {id = 8143, name = GetSpellInfo(8143)},
	TotemicRecall = {id = 36936, name = GetSpellInfo(36936)},
	Riptide = {id = 61295, name = GetSpellInfo(61295)},
	ManaSpringTotem = {id = 25570, name = GetSpellInfo(25570)},
	EarthShield = {id = 32593, name = GetSpellInfo(32593)},
	EarthlivingWeapon = {id = 51992, name = GetSpellInfo(51992)},
	HealingStreamTotem = {id = 10463, name = GetSpellInfo(10463)},
	NaturesSwiftness = {id = 16188, name = GetSpellInfo(16188)},
	CureToxins = {id = 526, name = GetSpellInfo(526)},
	ChainHeal = {id = 25422, name = GetSpellInfo(25422)},
	HealingWave = {id = 25391, name = GetSpellInfo(25391)},
	LesserHealingWave = {id = 25420, name = GetSpellInfo(25420)},
	AncestralSpirit = {id = 20777, name = GetSpellInfo(20777)},
	CleansingTotem = {id = 8170, name = GetSpellInfo(8170)},
	ManaTideTotem = {id = 16190, name = GetSpellInfo(16190)}
}

local lastSpell, lastUnit

local function LosCast(spell, tar)
	if ni.player.los(tar) and IsSpellInRange(spell, tar) == 1 then
		ni.spell.cast(spell, tar)
		lastSpell = spell
		lastUnit = tar
		if enables["TargetUnit"] then
			TargetUnit(tar)
		end
		return true
	end
	return false
end

local function ValidUsable(id, tar)
	if ni.spell.available(id) and ni.spell.valid(tar, id, false, true, true) then
		return true
	end
	return false
end

--GetTotemInfo
local fireSlot, earthSlot, waterSlot, airSlot = 1, 2, 3, 4
local function HasTotem(slot, name)
	local haveTotem, totemName = GetTotemInfo(slot)
	if haveTotem and totemName == name then
		return true
	end
	if haveTotem and totemName == nil then
		return true
	end
	return false
end
local function TotemTimeRemaining(slot, name)
	if not HasTotem(slot, name) then
		return 0
	end
	local _, _, startTime, duration = GetTotemInfo(slot)
	return startTime + duration - GetTime()
end

local abilities = {
	["Pause"] = function()
		if IsMounted() or UnitIsDeadOrGhost("player") then
			return true
		end
	end,
	["CancelCast"] = function()
		local spellName, _, _, _, endTime = UnitCastingInfo("player")
		if enables["CancelCast"] and spellName ~= nil then
			local finish = endTime/1000 - GetTime()
			if ni.unit.exists(lastUnit) and ni.unit.hp(lastUnit) >= values["CancelCast"] and finish >= 0.25 then
				ni.spell.stopcasting()
				return true
			end
		end
	end,
	["WaterShield"] = function()
		if ni.spell.available(spells.WaterShield.name) and not ni.player.buff(spells.WaterShield.name) then
			ni.spell.cast(spells.WaterShield.name)
			return true
		end
	end,
	["EarthlivingWeapon"] = function()
		local enchant = GetWeaponEnchantInfo()
		if
			ni.spell.available(spells.EarthlivingWeapon.name) and enchant ~= 1 and
				not ni.player.buff(spells.EarthlivingWeapon.name)
		 then
			ni.spell.cast(spells.EarthlivingWeapon.name)
			return true
		end
	end,
	["Tank Heal"] = function()
		local mainTank, offTank = ni.tanks()
		--Earthsheild focus
		if menus["EarthShieldTar"] == 3 and ni.unit.exists("focus") then
			local es, _, _, esCount, _, _, esTime = ni.unit.buff("focus", spells.EarthShield.name, "player")
			if
				(not es or esTime - GetTime() < 2) and ValidUsable(spells.EarthShield.name, "focus") and
					LosCast(spells.EarthShield.name, "focus")
			 then
				return true
			end
		end
		if mainTank ~= nil and ni.unit.exists(mainTank) then
			--EarthShield mainTank
			local esM, _, _, esMCount, _, _, esMTime = ni.unit.buff(mainTank, spells.EarthShield.name, "player")
			if
				(not esM or esMCount < 2 or esMTime - GetTime() < 2) and menus["EarthShieldTar"] == 1 and
					ValidUsable(spells.EarthShield.name, mainTank) and
					LosCast(spells.EarthShield.name, mainTank)
			 then
				return true
			end
			--Riptide mainTank
			if
				enables["RiptideTank"] and not ni.unit.buff(mainTank, spells.Riptide.name, "player") and
					ni.unit.hp(mainTank) <= values["RiptideTank"] and
					ValidUsable(spells.Riptide.name, mainTank) and
					LosCast(spells.Riptide.name, mainTank)
			 then
				return true
			end
			--HealingWave mainTank
			if
				enables["HealingWaveTank"] and not ni.player.ismoving() and ni.unit.hp(mainTank) <= values["HealingWaveTank"] and
					ValidUsable(spells.HealingWave.name, mainTank) and
					LosCast(spells.HealingWave.name, mainTank)
			 then
				return true
			end
			--LesserHealingWave mainTank
			if
				enables["LesserHealingWaveTank"] and not ni.player.ismoving() and
					ni.unit.hp(mainTank) <= values["LesserHealingWaveTank"] and
					ValidUsable(spells.LesserHealingWave.name, mainTank) and
					LosCast(spells.LesserHealingWave.name, mainTank)
			 then
				return true
			end
			--offTank
			if offTank ~= nil and ni.unit.exists(offTank) then
				--EarthShield offTank
				local esO, _, _, esOCount, _, _, esOTime = ni.unit.buff(mainTank, spells.EarthShield.name, "player")
				if
					(not esO or esOCount < 2 or esOTime - GetTime() < 2) and menus["EarthShieldTar"] == 2 and
						ValidUsable(spells.EarthShield.name, offTank) and
						LosCast(spells.EarthShield.name, offTank)
				 then
					return true
				end
				--Riptide offTank
				if
					enables["RiptideTank"] and ni.unit.hp(offTank) <= values["RiptideTank"] and
						not ni.unit.buff(offTank, spells.Riptide.name, "player") and
						ValidUsable(spells.Riptide.name, offTank) and
						LosCast(spells.Riptide.name, offTank)
				 then
					return true
				end
				--HealingWave offTank
				if
					enables["HealingWaveTank"] and not ni.player.ismoving() and ni.unit.hp(offTank) <= values["HealingWaveTank"] and
						ValidUsable(spells.HealingWave.name, offTank) and
						LosCast(spells.HealingWave.name, offTank)
				 then
					return true
				end
				--LesserHealingWave offTank
				if
					enables["LesserHealingWaveTank"] and not ni.player.ismoving() and
						ni.unit.hp(offTank) <= values["LesserHealingWaveTank"] and
						ValidUsable(spells.LesserHealingWave.name, offTank) and
						LosCast(spells.LesserHealingWave.name, offTank)
				 then
					return true
				end
			end
		end
	end,
	["Riptide"] = function()
		for i = 1, #ni.members do
			if
				ni.members[i].hp <= values["RiptideHP"] and not ni.unit.buff(ni.members[i].unit, spells.Riptide.name, "player") and
					ValidUsable(spells.Riptide.name, ni.members[i].unit) and
					LosCast(spells.Riptide.name, ni.members[i].unit)
			 then
				return true
			end
		end
	end,
	["LesserHealingWave"] = function()
		if not ni.player.ismoving() then
			for i = 1, #ni.members do
				if
					ni.members[i].hp <= values["LesserHealingWave"] and ValidUsable(spells.LesserHealingWave.name, ni.members[i].unit) and
						LosCast(spells.LesserHealingWave.name, ni.members[i].unit)
				 then
					return true
				end
			end
		end
	end,
	["HealingWave"] = function()
		if not ni.player.ismoving() then
			for i = 1, #ni.members do
				if
					ni.members[i].hp <= values["HealingWaveHP"] and ValidUsable(spells.HealingWave.id, ni.members[i].unit) and
						LosCast(spells.HealingWave.name, ni.members[i].unit)
				 then
					return true
				end
			end
		end
	end,
	["ChainHeal"] = function()
		if ni.spell.available(spells.ChainHeal.name) then
			GetTableForBestUnit(values["ChainHealHP"], 10, 3)
			if #customtable > 0 then
				if customtable[1].unitsclose >= 3 and ValidUsable(spells.ChainHeal.name, customtable[1].unit) then
					if customtable[1].hp <= values["ChainHealHP"] then
						LosCast(spells.ChainHeal.name, customtable[1].unit)
						return true
					end
				end
			end
		end
	end,
	["LightningBolt"] = function()
		if
			enables["LightningBolt"] and UnitExists("target") and UnitCanAttack("player", "target") and
				not UnitIsDeadOrGhost("target") and
				UnitAffectingCombat("player", "target") and
				ni.spell.available(spells.LightningBolt.name) and
				ni.spell.valid("target", spells.LightningBolt.name, true, true)
		 then
			ni.spell.cast(spells.LightningBolt.name, "target")
			return true
		end
	end
}
	ni.bootstrap.profile("Restro_Wrath", queue, abilities, OnLoad, OnUnload)
else
    local queue = {
        "Error",
    };
    local abilities = {
        ["Error"] = function()
            ni.vars.profiles.enabled = false;
			if not wotlk then
				ni.frames.floatingtext:message("This profile for WotLK 3.3.5a!")
            end
        end,
    };
    ni.bootstrap.profile("Restro_Wrath", queue, abilities);
end;

-------------------------------------
-- end of example file
--------------------------------------

--------------------------------
-- this is an example, filename: Ele_wrath.lua
---------------------------------

local build = select(4, GetBuildInfo());
local wotlk = build == 30300 or false;
if wotlk then

local queue = {
	"Pause",
	"FlametongueWeapon",
	"WindShear",
	"LightningShield",
	"WaterShield",
	"LavaBurst",
	"FlameShock",
	"EarthShock",
	"ChainLightning",
	"LightningBolt"
}
local enables = {
	["EarthShock"] = false,
	["LightningShield"] = false
}
local items = {
	settingsfile = "FElementalWrath.xml",
	{type = "title", text = "Elemental Wrath"},
	{
		type = "entry",
		text = "LightningShield",
		tooltip = "Use Lightning Shield",
		enabled = enables["LightningShield"],
		key = "LightningShield"
	},
	{
		type = "entry",
		text = "Earth Shock",
		tooltip = "Use Earth Shock",
		enabled = enables["EarthShock"],
		key = "EarthShock"
	}
}
local incombat = false
local function CombatEventCatcher(event, ...)
	if event == "PLAYER_REGEN_DISABLED" then
		incombat = true
	elseif event == "PLAYER_REGEN_ENABLED" then
		incombat = false
	end
end
local function OnLoad()
	ni.combatlog.registerhandler("ElementalWrath", CombatEventCatcher)
	ni.GUI.AddFrame("ElementalWrath", items)
end
local function OnUnload()
	ni.combatlog.unregisterhandler("ElementalWrath")
	ni.GUI.DestroyFrame("ElementalWrath")
end

local spells = {
	--General
	GiftoftheNaaru = {id = 59547, name = GetSpellInfo(59547)},
	AutoAttack = {id = 6603, name = GetSpellInfo(6603)},
	--Elemental Combat
	WindShear = {id = 57994, name = GetSpellInfo(57994)},
	StoneclawTotem = {id = 58582, name = GetSpellInfo(58582)},
	ElementalMastery = {id = 16166, name = GetSpellInfo(16166)},
	CalloftheElements = {id = 66842, name = GetSpellInfo(66842)},
	FlameShock = {id = 49233, name = GetSpellInfo(49233)},
	FireElementalTotem = {id = 2894, name = GetSpellInfo(2894)},
	Thunderstorm = {id = 59159, name = GetSpellInfo(59159)},
	Purge = {id = 8012, name = GetSpellInfo(8012)},
	CalloftheSpirits = {id = 66844, name = GetSpellInfo(66844)},
	EarthShock = {id = 49231, name = GetSpellInfo(49231)},
	Hex = {id = 51514, name = GetSpellInfo(51514)},
	EarthbindTotem = {id = 2484, name = GetSpellInfo(2484)},
	LavaBurst = {id = 60043, name = GetSpellInfo(60043)},
	LightningBolt = {id = 49238, name = GetSpellInfo(49238)},
	ElementalOath = {id = 51470, name = GetSpellInfo(51470)},
	FrostShock = {id = 49236, name = GetSpellInfo(49236)},
	MagmaTotem = {id = 58734, name = GetSpellInfo(58734)},
	FireNova = {id = 61657, name = GetSpellInfo(61657)},
	CalloftheAncestors = {id = 66843, name = GetSpellInfo(66843)},
	SearingTotem = {id = 58704, name = GetSpellInfo(58704)},
	TotemofWrath = {id = 57722, name = GetSpellInfo(57722)},
	ChainLightning = {id = 49271, name = GetSpellInfo(49271)},
	--Enhancement
	FrostResistanceTotem = {id = 58745, name = GetSpellInfo(58745)},
	FlametongueWeapon = {id = 58790, name = GetSpellInfo(58790)},
	GhostWolf = {id = 2645, name = GetSpellInfo(2645)},
	FireResistanceTotem = {id = 58739, name = GetSpellInfo(58739)},
	Heroism = {id = 32182, name = GetSpellInfo(32182)},
	WindfuryTotem = {id = 8512, name = GetSpellInfo(8512)},
	WrathofAirTotem = {id = 3738, name = GetSpellInfo(3738)},
	LightningShield = {id = 49281, name = GetSpellInfo(49281)},
	FrostbrandWeapon = {id = 58796, name = GetSpellInfo(58796)},
	SentryTotem = {id = 6495, name = GetSpellInfo(6495)},
	WindfuryWeapon = {id = 58804, name = GetSpellInfo(58804)},
	WaterWalking = {id = 546, name = GetSpellInfo(546)},
	EarthElementalTotem = {id = 2062, name = GetSpellInfo(2062)},
	StoneskinTotem = {id = 58753, name = GetSpellInfo(58753)},
	StrengthofEarthTotem = {id = 58643, name = GetSpellInfo(58643)},
	FlametongueTotem = {id = 58656, name = GetSpellInfo(58656)},
	WaterBreathing = {id = 131, name = GetSpellInfo(131)},
	RockbiterWeapon = {id = 10399, name = GetSpellInfo(10399)},
	NatureResistanceTotem = {id = 58749, name = GetSpellInfo(58749)},
	AstralRecall = {id = 556, name = GetSpellInfo(556)},
	FarSight = {id = 6196, name = GetSpellInfo(6196)},
	GroundingTotem = {id = 8177, name = GetSpellInfo(8177)},
	--Restoration
	WaterShield = {id = 57960, name = GetSpellInfo(57960)},
	ManaSpringTotem = {id = 58774, name = GetSpellInfo(58774)},
	TotemicRecall = {id = 36936, name = GetSpellInfo(36936)},
	EarthlivingWeapon = {id = 51994, name = GetSpellInfo(51994)},
	HealingStreamTotem = {id = 58757, name = GetSpellInfo(58757)},
	CureToxins = {id = 526, name = GetSpellInfo(526)},
	ChainHeal = {id = 55459, name = GetSpellInfo(55459)},
	TremorTotem = {id = 8143, name = GetSpellInfo(8143)},
	LesserHealingWave = {id = 49276, name = GetSpellInfo(49276)},
	AncestralSpirit = {id = 49277, name = GetSpellInfo(49277)},
	CleansingTotem = {id = 8170, name = GetSpellInfo(8170)},
	HealingWave = {id = 49273, name = GetSpellInfo(49273)}
}

local enemies = {}

local function ActiveEnemies(range)
	table.wipe(enemies)
	enemies = ni.player.enemiesinrange(range)
	for k, v in ipairs(enemies) do
		if ni.player.threat(v.guid) == -1 then
			table.remove(enemies, k)
		end
	end
	return #enemies
end

local function FacingLosCast(spell, tar)
	if ni.player.isfacing(tar, 145) and ni.player.los(tar) and IsSpellInRange(spell, tar) == 1 then
		ni.spell.cast(spell, tar)
		ni.debug.log(spell)
		return true
	end
	return false
end

local function ValidUsable(id, tar)
	if ni.spell.available(id) and ni.spell.valid(tar, id, true, true) then
		return true
	end
	return false
end

--GetTotemInfo
local fireSlot, earthSlot, waterSlot, airSlot = 1, 2, 3, 4
local function HasTotem(slot, name)
	local haveTotem, totemName = GetTotemInfo(slot)
	if haveTotem and totemName == name then
		return true
	end
	if haveTotem and totemName == nil then
		return true
	end
	return false
end
local function TotemTimeRemaining(slot, name)
	if not HasTotem(slot, name) then
		return 0
	end
	local _, _, startTime, duration = GetTotemInfo(slot)
	return startTime + duration - GetTime()
end

local abilities = {
	["Pause"] = function()
		if
			IsMounted() or UnitIsDeadOrGhost("player") or not UnitExists("target") or UnitIsDeadOrGhost("target") or
				(UnitExists("target") and not UnitCanAttack("player", "target"))
		 then
			return true
		end
	end,
	["LightningShield"] = function()
		if
			enables["LightningShield"] and ni.spell.available(spells.LightningShield.name) and
				not ni.player.buff(spells.LightningShield.name)
		 then
			ni.spell.cast(spells.LightningShield.name)
			return true
		end
	end,
	["WindShear"] = function()
		local cd = ni.spell.cd(spells.WindShear.id)
		if cd == 0 and ni.spell.shouldinterrupt("target") and FacingLosCast(spells.WindShear.name, "target") then
			return true
		end
	end,
	["WaterShield"] = function()
		if
			not enables["LightningShield"] and ni.spell.available(spells.WaterShield.name) and
				not ni.player.buff(spells.WaterShield.name)
		 then
			ni.spell.cast(spells.WaterShield.name)
			return true
		end
	end,
	["FlametongueWeapon"] = function()
		if ni.spell.available(spells.FlametongueWeapon.name) and --not really a great way to check if its present but wtf
				not GetWeaponEnchantInfo() then
			ni.spell.cast(spells.FlametongueWeapon.name)
			return true
		end
	end,
	["FlameShock"] = function()
		if
			incombat and ValidUsable(spells.FlameShock.name, "target") and
				ni.unit.debuffremaining("target", spells.FlameShock.id, "player") <= 2 and
				FacingLosCast(spells.FlameShock.name, "target")
		 then
			return true
		end
	end,
	["LavaBurst"] = function()
		if
			incombat and ValidUsable(spells.LavaBurst.name, "target") and
				ni.unit.debuffremaining("target", spells.FlameShock.id, "player") >= 2 and
				FacingLosCast(spells.LavaBurst.name, "target")
		 then
			return true
		end
	end,
	["EarthShock"] = function()
		if
			enables["EarthShock"] and ValidUsable(spells.EarthShock.name, "target") and
				FacingLosCast(spells.EarthShock.name, "target")
		 then
			return true
		end
	end,
	["ChainLightning"] = function()
		local chain = ni.unit.enemiesinrange("target", 8)
		if
			#chain > 1 and not ni.player.ismoving() and ValidUsable(spells.ChainLightning.id, "target") and
				FacingLosCast(spells.ChainLightning.name, "target")
		 then
			return true
		end
	end,
	["LightningBolt"] = function()
		if
			ValidUsable(spells.LightningBolt.name, "target") and not ni.player.ismoving() and
				FacingLosCast(spells.LightningBolt.name, "target")
		 then
			return true
		end
	end
}
	ni.bootstrap.profile("Ele_Wrath", queue, abilities, OnLoad, OnUnload)
else
    local queue = {
        "Error",
    };
    local abilities = {
        ["Error"] = function()
            ni.vars.profiles.enabled = false;
			if not wotlk then
				ni.frames.floatingtext:message("This profile for WotLK 3.3.5a!")
            end
        end,
    };
    ni.bootstrap.profile("Ele_Wrath", queue, abilities);
end;
----------------------------------------
-- end of example file
---------------------------------------


---------------------------------
-- this is an example, filename: mage - fire pve by dreams.lua
---------------------------------

local build = select(4, GetBuildInfo());
local wotlk = build == 30300 or false;
if wotlk then
local items = {
	settingsfile = "Mage - Fire PvE by Dreams.json",
	{ type = "title", text = "Mage - Fire PvE by |c0000CED1Dreams" },
	{ type = "separator" },
	{ type = "title", text = "|cffFFFF00Settings" },
	{ type = "entry", text = "\124T"..GetItemIcon(36799)..":26:26\124t Use Mana Gem < MP%", tooltip = "Use Mana Gem < MP%", enabled = true, value = 70, key = "ManaGem" },
	{ type = "entry", text = "\124T"..select(3, GetSpellInfo(12051))..":26:26\124t Use Evocation < MP%", tooltip = "Use Evocation < MP%", enabled = true, value = 10, key = "Evocation" },
	{ type = "entry", text = "\124T"..select(3, GetSpellInfo(55342))..":26:26\124t Use Mirror Image", tooltip = "Use Mirror Image", enabled = true, key = "MirrorImage" },
	{ type = "entry", text = "\124T"..select(3, GetSpellInfo(11129))..":26:26\124t Use Combustion", tooltip = "Use Combustion", enabled = true, key = "Combustion" },
	{ type = "entry", text = "\124T"..select(3, GetSpellInfo(42859))..":26:26\124t Use Scorch", tooltip = "Use Scorch", enabled = true, key = "Scorch" },
	{ type = "entry", text = "\124T"..select(3, GetSpellInfo(42873))..":26:26\124t Use Fireblast while moving", tooltip = "Use Fireblast", enabled = true, key = "Fireblast" },
};
 
local function GetSetting(name)
    for k, v in ipairs(items) do
        if v.type == "entry"
         and v.key ~= nil
         and v.key == name then
            return v.value, v.enabled
        end
    end
end;

local function OnLoad()
	ni.GUI.AddFrame("Mage - Fire PvE by Dreams", items);
end

local function OnUnLoad()  
	ni.GUI.DestroyFrame("Mage - Fire PvE by Dreams");
end

local spells = {
	ConjureManaGem = {id = 42985, name = GetSpellInfo(42985)},
	MoltenArmor = {id = 43046, name = GetSpellInfo(43046)},
	ArcaneBrilliance = {id = 43002, name = GetSpellInfo(43002)},
	Evocation = {id = 12051, name = GetSpellInfo(12051)},
	Pyroblast = {id = 42891, name = GetSpellInfo(42891)},
	Scorch = {id = 42859, name = GetSpellInfo(42859)},
	LivingBomb = {id = 55360, name = GetSpellInfo(55360)},
	MirrorImage = {id = 55342, name = GetSpellInfo(55342)},
	Combustion = {id = 11129, name = GetSpellInfo(11129)},
	Fireblast = {id = 42873, name = GetSpellInfo(42873)},
	Fireball = {id = 42833, name = GetSpellInfo(42833)}
};

local queue = {
    "Molten Armor",
    "Arcane Brilliance",
	"Conjure Mana Gem",
	"Mana Gem",
	"Fireblast",
    "Evocation",
    "Pyroblast",
    "Scorch",
    "Living Bomb",
	"Mirror Image",
    "Combustion",
    "Fireball"
};
 
local abilities = {
	["Molten Armor"] = function()
		if ni.spell.available(spells.MoltenArmor.id)
			and not ni.unit.ischanneling("player")
			and not ni.player.buff(spells.MoltenArmor.id) then
				ni.spell.cast(spells.MoltenArmor.name)
				return true;
		end
	end,

	["Arcane Brilliance"] = function()
		if ni.spell.available(spells.ArcaneBrilliance.id) 
			and not ni.player.buff(spells.ArcaneBrilliance.id) then
				ni.spell.cast(spells.ArcaneBrilliance.name)
				return true;
		end
	end, 

	["Conjure Mana Gem"] = function()
		if ni.spell.available(spells.ConjureManaGem.id) 
			and not ni.player.ismoving()
			and not UnitAffectingCombat("player")
			and not ni.player.hasitem(33312) -- Mana Sapphire --
			and not ni.unit.ischanneling("player") then 
				ni.spell.cast(spells.ConjureManaGem.name)
				return true;	
		end 
	end,

	["Mana Gem"] = function()
	local value, enabled = GetSetting("ManaGem")
		if enabled
			and UnitAffectingCombat("player")
			and ni.player.power() <= value
			and not ni.unit.ischanneling("player")
			and ni.player.hasitem(33312) -- Mana Sapphire --
			and ni.player.itemcd(33312) < 1 then -- Mana Sapphire --
				ni.player.useitem(33312) -- Mana Sapphire --
				return true;
		end
	end,

	["Evocation"] = function()
	local value, enabled = GetSetting("Evocation")
		if enabled
			and ni.spell.available(spells.Evocation.id)
			and UnitAffectingCombat("player")
			and ni.player.power() <= value
			and not ni.unit.ischanneling("player") then
				ni.spell.cast(spells.Evocation.name, "player")
				return true;
		end 
	end,

	["Pyroblast"] = function()
		if ni.spell.available(spells.Pyroblast.id)
			and UnitAffectingCombat("player")
			and ni.unit.buff("player", 48108, "player") -- Hot Streak --
			and not ni.unit.ischanneling("player") then
				ni.spell.cast(spells.Pyroblast.name, "target")
				return true;
		end
	end,

	["Scorch"] = function()
	local _, enabled = GetSetting("Scorch")
		if enabled 
			and ni.spell.available(spells.Scorch.id)
			and UnitAffectingCombat("player")
			and ni.unit.isboss("target")
			and ni.unit.debuff("target", 22959, "player") == nil -- Improved Scorch --
			and ni.unit.debuff("target", 17803, "player") == nil -- Improved Shadow Bolt --
			and not ni.unit.ischanneling("player") then
				ni.spell.cast(spells.Scorch.name, "target")
				return true;
		end
	end,

	["Living Bomb"] = function()
		if ni.spell.available(spells.LivingBomb.id)
			and UnitAffectingCombat("player")
			and ni.unit.debuff("target", 55360, "player") == nil -- Living Bomb --
			and not ni.unit.ischanneling("player") then
				ni.spell.cast(spells.LivingBomb.name, "target")
				return true;
		end
	end,

	["Mirror Image"] = function()
	local _, enabled = GetSetting("MirrorImage")
		if enabled
			and ni.unit.isboss("target") 
			and UnitAffectingCombat("player")
			and ni.spell.available(spells.MirrorImage.id) 
			and not ni.unit.ischanneling("player") then
				ni.spell.cast(spells.MirrorImage.name, "player")
				return true;
		end
	end,

	["Combustion"] = function()
	local _, enabled = GetSetting("Combustion")
		if enabled
			and ni.unit.isboss("target") 
			and UnitAffectingCombat("player")
			and ni.spell.available(spells.Combustion.id)  
			and not ni.unit.ischanneling("player") then
				ni.spell.cast(spells.Combustion.name, "player")
				return true;
		end
	end,

	["Fireblast"] = function()
	if ni.spell.available(spells.Fireblast.id) 
			and UnitAffectingCombat("player")
			and not ni.unit.ischanneling("player") 
			and ni.unit.ismoving("player") then
				ni.spell.cast(spells.Fireblast.name, "target")
				return true;
		end
	end,

	["Fireball"] = function()
	if ni.spell.available(spells.Fireball.id) 
			and UnitAffectingCombat("player")
			and not ni.unit.ischanneling("player") then
				ni.spell.cast(spells.Fireball.name, "target")
				return true;
		end
	end,
};
	ni.bootstrap.profile("Mage - Fire PvE by Dreams", queue, abilities, OnLoad, OnUnLoad);	
else
    local queue = {
        "Error",
    };
    local abilities = {
        ["Error"] = function()
            ni.vars.profiles.enabled = false;
			if not wotlk then
				ni.frames.floatingtext:message("This profile for WotLK 3.3.5a!")
            end
        end,
    };
    ni.bootstrap.profile("Mage - Fire PvE by Dreams", queue, abilities);
end;

-------------------------------
---- end of example file
--------------------------------

-----------------------------
--- this is an example, filename: frost_wrath.lua
----------------------------

local build = select(4, GetBuildInfo());
local wotlk = build == 30300 or false;
if wotlk then
local queue = {
	"Pause",
	"FrostArmor",
	"ArcaneIntellect",
	"Blizzard",
	"Frostbolt",
	"Fireball"
}
local enables = {
	["Blizzard"] = true,
}
local values = {
	["Blizzard"] = 3,
}
local inputs = {
}
local menus = {
}
local function GUICallback(key, item_type, value)
	if item_type == "enabled" then
		enables[key] = value;
	elseif item_type == "value" then
		values[key] = value;
	elseif item_type == "input" then
		inputs[key] = value;
	elseif item_type == "menu" then
		menus[key] = value;
	end
end
local items = {
	settingsfile = "FrostWrath.xml",
	callback = GUICallback,
	{ type = "title", text = "Frost Wrath" },
	{
		type = "entry",
		text = "Blizzard",
		tooltip = "Blizzard AoE Count",
		enabled = enables["Blizzard"],
		value = values["Blizzard"],
		key = "Blizzard"
	},
};
local incombat = false;
local function CombatEventCatcher(event, ...)
	if event == "PLAYER_REGEN_DISABLED" then
		incombat = true;
	elseif event == "PLAYER_REGEN_ENABLED" then
		incombat = false;
	end
end
local function OnLoad()
	ni.combatlog.registerhandler("FrostWrath", CombatEventCatcher);
	ni.GUI.AddFrame("FrostWrath", items);
end
local function OnUnload()
	ni.combatlog.unregisterhandler("FrostWrath");
	ni.GUI.DestroyFrame("FrostWrath");
end

local spells = {
--General
Shoot = {id = 5019, name = GetSpellInfo(5019)},
ArcaneTorrent = {id = 28730, name = GetSpellInfo(28730)},
AutoAttack = {id = 6603, name = GetSpellInfo(6603)},
--Arcane
ArcaneIntellect = {id = 1459, name = GetSpellInfo(1459)},
ConjureWater = {id = 5504, name = GetSpellInfo(5504)},
--Fire
Fireball = {id = 133, name = GetSpellInfo(133)},
--Frost
Frostbolt = {id = 116, name = GetSpellInfo(116)},
FrostArmor = {id = 168, name = GetSpellInfo(168)},
}

local function FacingLosCast(spell, tar)
	if ni.player.isfacing(tar, 145) and ni.player.los(tar) and IsSpellInRange(spell, tar) == 1 then
		ni.spell.cast(spell, tar)
		ni.debug.log(spell)
		return true
	end
	return false
end

local function ValidUsable(id, tar)
	if ni.spell.available(id) and ni.spell.valid(tar, id, true, true) then
		return true
	end
	return false
end


local abilities = {
	["FrostArmor"]= function()
		if not ni.player.buff(spells.FrostArmor.name)
		and ni.spell.available(spells.FrostArmor.name) then
			ni.spell.cast(spells.FrostArmor.name)
			return true
			end
	end,
	["ArcaneIntellect"]= function()
		if not ni.player.buff(spells.ArcaneIntellect.name)
		and ni.spell.available(spells.ArcaneIntellect.name) then
			ni.spell.cast(spells.ArcaneIntellect.name)
			return true
			end
	end,
	["Pause"] = function()
		if IsMounted()
			or UnitIsDeadOrGhost("player")
			or not UnitExists("target")
			or UnitIsDeadOrGhost("target")
			or (UnitExists("target") and not UnitCanAttack("player", "target")) then
			return true
		end
	end,
	["Blizzard"] = function()
		if enables["Blizzard"]
		and incombat
		and IsSpellInRange(spells.Frostbolt.name, "target") == 1
		and not ni.player.ismoving()
		and ni.player.los("target") then
			local nearby = #ni.unit.enemiesinrange("target", 8)
			local n = UnitChannelInfo("player")
			if n ~= nil and n == spells.Blizzard.name
			and nearby >= values["Blizzard"] then
				return true
				end
			if ni.spell.available(spells.Blizzard.name)
			and nearby >= values["Blizzard"] then
				ni.spell.castat(spells.Blizzard.name, "target", 1)
				return true
				end
		end
	end,
	["Frostbolt"] = function()
		if ValidUsable(spells.Frostbolt.name, "target")
		and not ni.player.ismoving()
		and FacingLosCast(spells.Frostbolt.name, "target") then
			return true
		end
	end,
	["Fireball"] = function()
		if ValidUsable(spells.Fireball.name, "target")
		and not ni.player.ismoving()
		and FacingLosCast(spells.Fireball.name, "target") then
			return true
		end
	end,
}
	ni.bootstrap.profile("Frost_Wrath", queue, abilities, OnLoad, OnUnload);
else
    local queue = {
        "Error",
    };
    local abilities = {
        ["Error"] = function()
            ni.vars.profiles.enabled = false;
			if not wotlk then
				ni.frames.floatingtext:message("This profile for WotLK 3.3.5a!")
            end
        end,
    };
    ni.bootstrap.profile("Frost_Wrath", queue, abilities);
end;

------------------------------
-- end of example file
------------------------------

------------------------------
-- this is an example, filename: free_restoration_darhangar.lua
-- restoration druid
-- wrath of the lich king
-- patch 3.3.5a
---------------------------------

local GetBuildInfo, select, ipairs, pairs, tonumber, GetSpellInfo, IsUsableSpell, GetTime, UnitAffectingCombat, IsMounted, ni_tanks, UnitInVehicle, UnitIsDeadOrGhost, UnitChannelInfo, UnitCastingInfo = GetBuildInfo, select, ipairs, pairs, tonumber, GetSpellInfo, IsUsableSpell, GetTime, UnitAffectingCombat, IsMounted, ni.tanks, UnitInVehicle, UnitIsDeadOrGhost, UnitChannelInfo, UnitCastingInfo
local build = select(4, GetBuildInfo());
local wotlk = build == 30300 or false;
if wotlk then
local AntiAFKTime = 0;
local items = {
	settingsfile = "DruidRestoEN_Free_Darhanger.json",
	{ type = "title", text = "Free Restoration Druid by |c0000CED1DarhangeR|r" },
	{ type = "separator" },
	{ type = "title", text = "|cffFF7C0AProfile version 0.0.2|r" },
	{ type = "separator" },
	{ type = "page", number = 1, text = "|cffFFFF00Main Settings" },
	{ type = "separator" },	
	{ type = "entry", text = ni.spell.icon(33891).." Auto Form", tooltip = "Auto use proper form.", enabled = true, key = "autoform" },	
	{ type = "entry", text = ni.spell.icon(52674).." Auto Buff", tooltip = "Enable Auto Buff player/ally.", enabled = true, key = "AutoBuff" },	
	{ type = "entry", text = ni.spell.icon(2382).." |cffffa500Debug Printing|r", tooltip = "Enable for debug if you have problems.", enabled = false, key = "Debug" },
	{ type = "page", number = 2, text = "|cff95f900CD's and important spells|r" },
	{ type = "separator" },
	{ type = "entry", text = ni.spell.icon(18562).." Swiftmend", tooltip = "Use spell when ally |cff00D700HP|r < %.", enabled = true, value = 60, min = 10, max = 100, step = 1, width = 40, key = "swift" },
	{ type = "entry", text = ni.spell.icon(17116).." Nature's Swiftness", tooltip = "Use spell when ally |cff00D700HP|r < %.\nWith Nature Swiftness also will be used [Healing Touch].", enabled = true, value = 40, min = 10, max = 100, step = 1, width = 40, key = "natureswift" },	
	{ type = "separator" },
	{ type = "entry", text = ni.spell.icon(48447).." Tranquility", tooltip = "Spell will be used when average |cff00D700HP|r\nof specified number allies is lower < %.", enabled = true, key = "tranquil" },
	{ type = "entry", text = "Tranquility (Ally HP)", tooltip = "Adjust ally average |cff00D700HP|r < %.", value = 37, min = 25, max = 100, step = 1, width = 40, key = "tranquilhp" },
	{ type = "entry", text = "Tranquility (Ally Count)", tooltip = "Adjust ally count in your party.", value = 4, min = 2, max = 5, step = 1, width = 40, key = "tranquilcount" },
	{ type = "separator" },	
	{ type = "title", text = "Dispel" },
	{ type = "separator" },
	{ type = "entry", text = ni.spell.icon(2782).." Remove Curse (Ally)", tooltip = "Auto dispel debuffs from ally.", enabled = true, key = "removecurse" },
	{ type = "entry", text = ni.spell.icon(2893).." Abolish Poison (Ally)", tooltip = "Auto dispel debuffs from ally.", enabled = true, key = "ambolishpoison" },	
	{ type = "page", number = 3, text = "|cff95f900Party/Raid Healing Settings|r" },
	{ type = "separator" },
	{ type = "entry", text = ni.spell.icon(48441).." Rejuvenation", tooltip = "Use spell when ally |cff00D700HP|r < %.", enabled = true, value = 99, min = 10, max = 100, step = 1, width = 40, key = "rejuall" },	
	{ type = "entry", text = ni.spell.icon(48438).." Wild Growth", tooltip = "Use spell when ally |cff00D700HP|r < %.", enabled = true, value = 95, min = 10, max = 100, step = 1, width = 40, key = "growth" },	
	{ type = "entry", text = ni.spell.icon(50464).." Nourish", tooltip = "Use spell when ally |cff00D700HP|r < %.", enabled = true, value = 75, min = 10, max = 100, step = 1, width = 40, key = "nourish" },	
	{ type = "page", number = 4, text = "|cff95f900Tank Settings|r" },
	{ type = "separator" },
	{ type = "entry", text = ni.spell.icon(2565).." Auto Track Tank", tooltip = "Auto Track Tank and mainly heal him.\nDruid support MAIN TANK and OFF TANK.", enabled = true, key = "healtank" },	
	{ type = "entry", text = ni.spell.icon(48441).." Rejuvenation", tooltip = "Always keeps [Rejuvenation] on Main Tank and Off Tank.", enabled = true, key = "rejuTanks" },	
	{ type = "entry", text = ni.spell.icon(50464).." Nourish", tooltip = "Use spell when tanks |cff00D700HP|r < %.", enabled = true, value = 70, min = 10, max = 100, step = 1, width = 40, key = "nouriTanks" },
	{ type = "page", number = 5, text = "|cff00C957Defensive Settings" },
	{ type = "separator" },	
	{ type = "entry", text = ni.spell.icon(22812).." Barkskin", tooltip = "Use spell when player |cff00D700HP|r < %.", enabled = true, value = 40, min = 15, max = 100, step = 1, width = 40, key = "barkskin" },	
};
local function GetSetting(name)
	for k, v in ipairs(items) do
		if v.type == "entry"
		and v.key ~= nil
		and v.key == name then
			return v.value, v.enabled;
		end
		if v.type == "dropdown"
		and v.key ~= nil
		and v.key == name then
			for k2, v2 in pairs(v.menu) do
				if v2.selected then
					return v2.value;
				end
			end
		end
		if v.type == "input"
		and v.key ~= nil
		and v.key == name then
			return v.value;
		end
	end
end;
local function OnLoad()
	ni.GUI.AddFrame("Free_Restoration_DarhangeR", items);
end;
local function OnUnLoad()  
	ni.GUI.DestroyFrame("Free_Restoration_DarhangeR");
end;
local function UsableSilence(spellid, stutter)
	if tonumber(spellid) == nil then
		spellid = ni.spell.id(spellid)
	end
	local result = false;
	if spellid == nil or spellid == 0 then
		return false;
	end
	local spellName = GetSpellInfo(spellid);
	if not ni.player.isstunned()
	and not ni.player.issilenced()
	and ni.spell.available(spellid, stutter)
	and IsUsableSpell(spellName) then
		result = true;
	end
	return result;
end;
local spells = {
MarkOfTheWild = GetSpellInfo(48469),
GiftOfTheWild = GetSpellInfo(48470),
TreeOfLife = GetSpellInfo(33891),
Thorns = GetSpellInfo(53307),
Innervate = GetSpellInfo(29166),
Barkskin = GetSpellInfo(22812),
Lifebloom = GetSpellInfo(48451),
Rejuvenation = GetSpellInfo(48441),
Regrowth = GetSpellInfo(48443),
Nourish = GetSpellInfo(50464),
WildGrowth = GetSpellInfo(53251),
Tranquility = GetSpellInfo(48447),
HealingTouch = GetSpellInfo(48378),
NatureSwiftness = GetSpellInfo(17116),
Swiftmend = GetSpellInfo(18562),
RemoveCurse = GetSpellInfo(2782),
AbolishPoison = GetSpellInfo(2893),
Cyclone = GetSpellInfo(33786),
	-- Proc --
Clearcasting = GetSpellInfo(16870),
};
local cache = {
IsMoving = false,
PlayerCombat = false,
};
local queue = {
"Cache",
"Universal Pause",
"Gift of the Wild",
"Thorns",
"Tree of Life",
"Barkskin",
"Combat Specific Pause",
"Nature's Swiftness",
"Swiftmend",	
"Wild Growth",
"Tank Heal",
"Rejuvenation",	
"Remove Curse (Ally)",
"Abolish Poison (Ally)",
"Nourish",	
};
local abilities = {
-----------------------------------
	["Cache"] = function()
		if GetTime() - AntiAFKTime > 80 then
			ni.utils.resetlasthardwareaction();
			AntiAFKTime = GetTime();
		end
		cache.IsMoving = ni.player.ismoving() or false;
		cache.PlayerCombat = UnitAffectingCombat("player") or false;
	end,
-----------------------------------
	["Universal Pause"] = function()
		if IsMounted()
		or UnitInVehicle("player")
		or UnitIsDeadOrGhost("player")
		or UnitChannelInfo("player")
		or UnitCastingInfo("player")
		or ni.player.islooting() then
			return true;
		end
		ni.vars.debug = select(2, GetSetting("Debug"));
	end,
-----------------------------------
	["Gift of the Wild"] = function()
		local _, enabled = GetSetting("AutoBuff");
		if not enabled then
			return false;
		end
		if cache.PlayerCombat
		or ni.player.buff(spells.MarkOfTheWild)
		or ni.player.buff(spells.GiftOfTheWild) then 
			return false;
		end
		if UsableSilence(spells.GiftOfTheWild) then
			ni.spell.cast(spells.GiftOfTheWild, "player")	
			return true;
		end
		if UsableSilence(spells.MarkOfTheWild)
		and not UsableSilence(spells.GiftOfTheWild) then
			ni.spell.cast(spells.MarkOfTheWild, "player")
			return true;
		end
	end,
-----------------------------------
	["Thorns"] = function()
		local _, enabled = GetSetting("AutoBuff");
		if not enabled then
			return false;
		end
		if cache.PlayerCombat then
			return false;
		end
		if UsableSilence(spells.Thorns)
		and not ni.player.buff(spells.Thorns) then
			ni.spell.cast(spells.Thorns, "player")
			return true;
		end
	end,
-----------------------------------	
	["Tree of Life"] = function()
		local _, enabled = GetSetting("autoform");
		if not enabled then
			return false;
		end
		if UsableSilence(spells.TreeOfLife)
		and not ni.unit.buff("player", 33891, "EXACT") then
			ni.spell.cast(spells.TreeOfLife)
			return true;
		end
	end,
-----------------------------------	
	["Barkskin"] = function()
		local value, enabled = GetSetting("barkskin");
		if not enabled
		or cache.PlayerCombat then
			return false;
		end
		if ni.player.hp() <= value
		and ni.spell.available(spells.Barkskin) 
		and not ni.player.buff(spells.Barkskin) then
			ni.spell.cast(spells.Barkskin)
			return true;
		end
	end,
-----------------------------------	
	["Combat Specific Pause"] = function()
		if cache.PlayerCombat then
			return false;
		end
		for i = 1, #ni.members do
		local ally = ni.members[i];
		if ally:combat() then
				return false;
			end
		end
		return true;
	end,
-----------------------------------
	["Swiftmend"] = function()
		local value, enabled = GetSetting("swift");
		if not enabled then
			return false;
		end
		if ni.spell.available(spells.Swiftmend) then
			for i = 1, #ni.members do
			local ally = ni.members[i];
				if ally:hp() <= value
				and ally.auras(spells.Rejuvenation.."||"..spells.Regrowth)
				and ally:valid(ally, spells.Swiftmend, false, true) then
					ni.spell.cast(spells.Swiftmend, ally.unit)
					return true;				
				end					
			end
		end
	end,
-----------------------------------
	["Nature's Swiftness"] = function()
		local value, enabled = GetSetting("natureswift");
		if not enabled then
			return false;
		end
		if UsableSilence(spells.NatureSwiftness)
		and UsableSilence(spells.HealingTouch) 
		and (ni.spell.cd(spells.Swiftmend) ~= 0 
		and ni.spell.cd(spells.Swiftmend) > 1.5) then
			local allyOne = ni.members[1];
			if allyOne:hp() <= value
			and allyOne:valid(allyOne, spells.HealingTouch, false, true) then
				ni.spell.cast(spells.NatureSwiftness)
				ni.spell.cast(spells.HealingTouch, allyOne.unit)
				return true;
			end
		end
	end,
-----------------------------------			
    ["Tranquility"] = function()
		if not ui("tranquil")[2]
		or cache.IsMoving then 
			return false;
		end
		local value = ui("tranquilhp")[1];
		local total = members.subgroupbelow(value, 30, true);
		if total >= ui("tranquilcount")[1]
		and usableSilence(spells.Tranquility) then
			spellCast(spells.Tranquility)
			return true;
		end
	end,
-----------------------------------		
	["Tank Heal"] = function()
		local mainTank, offTank = ni_tanks();
		local _, enabled = GetSetting("healtank");
		local _, rejEnable = GetSetting("rejuTanks");
		local nourVal, nourEnable = GetSetting("nouriTanks");
		if not enabled then
			return false;
		end
		if mainTank then
			if UnitExists(mainTank.unit)
			and ni.spell.valid(mainTank.unit, spells.HealingTouch, false, true, true) then	
				if nourEnable then
					if not cache.IsMoving
					and ni.unit.hp(mainTank.unit) <= nourVal
					and UsableSilence(spells.Nourish) then
						if (ni.unit.buff(mainTank.unit, spells.Rejuvenation)
						or ni.unit.buff(mainTank.unit, spells.WildGrowth)) then
							ni.spell.cast(spells.Nourish, mainTank.unit) 
							return true;
						end
					end
				end
				if rejEnable then
					if UsableSilence(spells.Rejuvenation)
					and not ni.unit.buff(mainTank.unit, spells.Rejuvenation, "player") then
						ni.spell.cast(spells.Rejuvenation, mainTank.unit)
						return true;
					end
				end
			end
		end
		if offTank then
			if UnitExists(offTank.unit) 
			and ni.spell.valid(offTank.unit, spells.HealingTouch, false, true, true) then	
				if nourEnable then
					if not cache.IsMoving
					and ni.unit.hp(offTank.unit) <= nourVal
					and UsableSilence(spells.Nourish) then
						if (ni.unit.buff(offTank.unit, spells.Rejuvenation)
						or ni.unit.buff(offTank.unit, spells.WildGrowth)) then
							ni.spell.cast(spells.Nourish, offTank.unit) 
							return true;
						end
					end
				end
				if rejEnable then
					if UsableSilence(spells.Rejuvenation)
					and not ni.unit.buff(offTank.unit, spells.Rejuvenation, "player") then
						ni.spell.cast(spells.Rejuvenation, offTank.unit)
						return true;
					end
				end
			end
		end
	end,
-----------------------------------			
	["Remove Curse (Ally)"] = function()
		local _, enabled = GetSetting("removecurse");
		if not enabled
		or not UsableSilence(spells.RemoveCurse) then
			return false;
		end
		for i = 1, #ni.members.sort() do
		local ally = ni.members[i];
			if ally:debufftype("Curse")	 
			and ally:dispel()
			and ni.spell.lastcast(spells.RemoveCurse, 1.8)
			and ally:valid(spells.RemoveCurse, false, true) then
				ni.spell.cast(spells.RemoveCurse, ally.unit)
				return true;
			end
		end
	end,
-----------------------------------	
	["Abolish Poison (Ally)"] = function()
		local _, enabled = GetSetting("removecurse");	
		if not enabled 
		or not UsableSilence(spells.AbolishPoison) then
			return false;
		end
		for i = 1, #ni.members.sort() do
		local ally = ni.members[i];
			if ally:debufftype("Poison")	 
			and ally:dispel()
			and not ally:aura(spells.AbolishPoison)
			and ni.spell.lastcast(spells.AbolishPoison, 1.8)
			and ally:valid(spells.AbolishPoison, false, true) then
				ni.spell.cast(spells.AbolishPoison, ally.unit)
				return true;
			end
		end
	end,
-----------------------------------	
	["Rejuvenation"] = function()
		local value, enabled = GetSetting("rejuall");
		if not enabled then
			return false;
		end
		if UsableSilence(spells.Rejuvenation) then
			for i = 1, #ni.members do
			local ally = ni.members[i];
				if ally:hp() <= value
				and not ally:buff(spells.Rejuvenation, "player")
				and ally:valid(spells.Rejuvenation, false, true) then
					ni.spell.cast(spells.Rejuvenation, ally.unit)
					return true;
				end	
			end
		end
	end,
-----------------------------------	
	["Nourish"] = function()
		local value, enabled = GetSetting("nourish");
		if not enabled
		or cache.IsMoving then
			return false;
		end
		if UsableSilence(spells.Nourish) then
			for i = 1, #ni.members do
			local ally = ni.members[i];
				if ally:hp() <= value
				and ally:auras(spells.Rejuvenation.."||"..spells.Regrowth.."||"..spells.Lifebloom.."||"..spells.WildGrowth)
				and ally:valid(spells.Nourish, false, true) then
					ni.spell.cast(spells.Nourish, ally.unit)
					return true;
				end
			end
		end
	end,
-----------------------------------	
	["Wild Growth"] = function()
		local value, enabled = GetSetting("growth");
		if not enabled
		or not UsableSilence(spells.WildGrowth) then
			return false;
		end
		local allyOne = ni.members[1];
		local ally = ni.members.inrangewithoutbuffbelow(allyOne.unit, 14, spells.WildGrowth, value);
		if #ally >= 3	 
		and allyOne:hp() <= value
		and allyOne:valid(spells.WildGrowth, false, true) then
			ni.spell.cast(spells.WildGrowth, allyOne.unit)
			return true;
		end
	end,
};
	ni.bootstrap.profile("Free_Restoration_DarhangeR", queue, abilities, OnLoad, OnUnLoad);
else
    local queue = {
        "Error",
    };
    local abilities = {
        ["Error"] = function()
            ni.vars.profiles.enabled = false;
			if not wotlk then
				ni.frames.floatingtext:message("This profile for WotLK 3.3.5a!")
            end
        end,
    };
    ni.bootstrap.profile("Free_Restoration_DarhangeR", queue, abilities);
end;

--------------------------------
-- end of example file
--------------------------------

---------------------------
-- example for warlock affliction
--------------------------

local build = select(4, GetBuildInfo());
local wotlk = build == 30300 or false;
if wotlk then

local queue = {
	"Pause",
	"SummonImp",
	"SummonVoidwalker",
	"DemonSkin",
	"PetAttack",
	"Immolate",
	"CurseofAgony",
	"Corruption",
	"ShadowBolt",
	"Wand"
}
local ImpC, VoidC = "|cff00ff00Imp", "|cFF800080Voidwalker"

local enables = {
	["Wand"] = false,
}
local values = {}
local inputs = {}
local menus = {
	["Summon"] = 1
}
local function GUICallback(key, item_type, value)
	if item_type == "enabled" then
		enables[key] = value
	elseif item_type == "value" then
		values[key] = value
	elseif item_type == "input" then
		inputs[key] = value
	elseif item_type == "menu" then
		menus[key] = value
	end
end
local items = {
	settingsfile = "AffWrath.xml",
	callback = GUICallback,
	{type = "title", text = "Afflction Wrath"},
	{type = "separator"},
	{type = "title", text = "Summon Selection"},
	{
		type = "dropdown",
		menu = {
			{
				selected = (menus["Summon"] == 1),
				value = 1,
				text = ImpC
			},
			{
				selected = (menus["Summon"] == 2),
				value = 2,
				text = VoidC
			}
		},
		key = "Summon"
	},
	{type = "separator"},
	{
		type = "entry",
		text = "Wand",
		tooltip = "Use Wand not shadowbolt",
		enabled = enables["Wand"],
		key = "Wand"
	},
}

local incombat = false

local function CombatEventCatcher(event, ...)
	if event == "PLAYER_REGEN_DISABLED" then
		incombat = true
	elseif event == "PLAYER_REGEN_ENABLED" then
		incombat = false
	end
end
local function OnLoad()
	ni.combatlog.registerhandler("Affliction_Wrath", CombatEventCatcher)
	ni.GUI.AddFrame("Affliction_Wrath", items)
end
local function OnUnload()
	ni.combatlog.unregisterhandler("Affliction_Wrath")
	ni.GUI.DestroyFrame("Affliction_Wrath")
end

local spells = {
	--General
	Shoot = {id = 5019, name = GetSpellInfo(5019)},
	ArcaneTorrent = {id = 28730, name = GetSpellInfo(28730)},
	AutoAttack = {id = 6603, name = GetSpellInfo(6603)},
	--Affliction
	Corruption = {id = 172, name = GetSpellInfo(172)},
	DrainSoul = {id = 1120, name = GetSpellInfo(1120)},
	LifeTap = {id = 1454, name = GetSpellInfo(1454)},
	CurseofWeakness = {id = 702, name = GetSpellInfo(702)},
	CurseofAgony = {id = 980, name = GetSpellInfo(980)},
	Fear = {id = 5782, name = GetSpellInfo(5782)},
	--Demonology
	SummonImp = {id = 688, name = GetSpellInfo(688)},
	CreateHealthstone = {id = 6201, name = GetSpellInfo(6201)},
	DemonSkin = {id = 696, name = GetSpellInfo(696)},
	SummonVoidwalker = {id = 697, name = GetSpellInfo(697)},
	--Destruction
	Immolate = {id = 707, name = GetSpellInfo(707)},
	ShadowBolt = {id = 695, name = GetSpellInfo(695)}
}

local lastSpell, lastTarget = "", ""

local function DoubleCast(spell, tar)
	if lastSpell == spell and lastTarget == UnitGUID(tar) then
		return true
	end
	return false
end

local function FacingLosCast(spell, tar)
	if ni.player.isfacing(tar, 145) and ni.player.los(tar) and IsSpellInRange(spell, tar) == 1 then
		ni.spell.cast(spell, tar)
		lastSpell = spell
		lastTarget = UnitGUID(tar)
		return true
	end
	return false
end

local function ValidUsable(id, tar)
	if ni.spell.available(id) and ni.spell.valid(tar, id, true, true) then
		return true
	end
	return false
end

local abilities = {
	["Pause"] = function()
		if
			IsMounted() or UnitIsDeadOrGhost("player") or not UnitExists("target") or UnitIsDeadOrGhost("target") or
				(UnitExists("target") and not UnitCanAttack("player", "target"))
		 then
			return true
		end
	end,
	["PetAttack"] = function()
		if UnitExists("pet") and not UnitIsDeadOrGhost("pet") then
			--Attack the same unit as player
			local petTarget = UnitGUID("pettarget")
			local playerTarget = UnitGUID("target")
			if petTarget ~= playerTarget then
				ni.player.runtext("/petattack")
			end
		end
	end,
	["DemonSkin"] = function()
		if not ni.player.buff(spells.DemonSkin.name) and ni.spell.available(spells.DemonSkin.name) then
			ni.spell.cast(spells.DemonSkin.name)
			return true
		end
	end,
	["SummonImp"] = function()
		if
			menus["Summon"] == 1 and (not (UnitExists("pet") == 1) or UnitIsDeadOrGhost("pet")) and
				ni.spell.available(spells.SummonImp.name) and
				not ni.player.ismoving()
		 then
			ni.spell.cast(spells.SummonImp.name)
			return true
		end
	end,
	["SummonVoidwalker"] = function()
		if
			menus["Summon"] == 2 and (not (UnitExists("pet") == 1) or UnitIsDeadOrGhost("pet")) and ni.player.hasitem(6263) and
				ni.spell.available(spells.SummonVoidwalker.name) and
				not ni.player.ismoving()
		 then
			ni.spell.cast(spells.SummonVoidwalker.name)
			return true
		end
	end,
	["Immolate"] = function()
		if
			ValidUsable(spells.Immolate.name, "target") and not ni.player.ismoving() and
				ni.unit.debuffremaining("target", spells.Immolate.name, "player") <= 2 and
				not DoubleCast(spells.Immolate.name, "target") and
				FacingLosCast(spells.Immolate.name, "target")
		 then
			return true
		end
	end,
	["Corruption"] = function()
		if
			ValidUsable(spells.Corruption.name, "target") and
				ni.unit.debuffremaining("target", spells.Corruption.id, "player") <= 2 and
				not DoubleCast(spells.Corruption.name, "target") and
				FacingLosCast(spells.Corruption.name, "target")
		 then
			return true
		end
	end,
	["CurseofAgony"] = function()
		if
			ValidUsable(spells.CurseofAgony.name, "target") and
				ni.unit.debuffremaining("target", spells.CurseofAgony.name, "player") <= 2 and
				not DoubleCast(spells.CurseofAgony.name, "target") and
				FacingLosCast(spells.CurseofAgony.name, "target")
		 then
			return true
		end
	end,
	["ShadowBolt"] = function()
		if not enables["Wand"] and
			ValidUsable(spells.ShadowBolt.name, "target") and not ni.player.ismoving() and
				FacingLosCast(spells.ShadowBolt.name, "target")
		 then
			return true
		end
	end,
	["Wand"] = function ()
		local hasWand = GetInventoryItemID("player", 18)
		if enables["Wand"] and
		hasWand ~= nil and
		not IsCurrentSpell(spells.Shoot.id)
		and not ni.player.ismoving() then
			ni.spell.cast(spells.Shoot.id, "target")
			lastSpell= spells.Shoot.name
			lastTarget = UnitGUID("target")
		end
	end
}
	ni.bootstrap.profile("Affliction_Wrath", queue, abilities, OnLoad, OnUnload)
else
    local queue = {
        "Error",
    };
    local abilities = {
        ["Error"] = function()
            ni.vars.profiles.enabled = false;
			if not wotlk then
				ni.frames.floatingtext:message("This profile for WotLK 3.3.5a!")
            end
        end,
    };
    ni.bootstrap.profile("Free_Restoration_DarhangeR", queue, abilities);
end;

-------------------------
-- end of example warlock affliction
-------------------------------



